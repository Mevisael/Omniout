/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { LightningElement, api, track } from "lwc";
import { isEqual, cloneDeep } from "c/lodash";
import { BaseFlexElementMixin } from "c/baseFlexElementMixin";
import { interpolateKeyValue, extractCustomLabelUsed } from "c/flexCardUtility";
import pubsub from "c/pubsub";
import multiSelectInput from "c/flexCardUtils";

export default class MultiSelectInput extends BaseFlexElementMixin(
  LightningElement
) {
  _propertyObj = {};
  _regexPattern = /\{([a-zA-Z.0-9_]*)\}/g; //for {} fields by default
  _interpolatedValue = {};
  _value;
  customLabels = {};
  excludeKeys = [
    "card",
    "propertyObj",
    "record",
    "recordId",
    "customProperties"
  ];

  @track _type = "";
  @track selectedElement = {};
  @track multiSelectLabel = multiSelectInput;
  @api theme;
  @api obj;
  @api element;
  @api action;
  @api extraclass;

  @api set styles(val) {
    if (val) {
      this._styles = val;
      Promise.resolve().then(() => {
        this.updateStyles();
      });
    }
  }
  get styles() {
    return this._styles;
  }

  @api set type(val) {
    if (val) {
      this._type = val;
      this.selectedElement[this._type] = true;
    }
  }
  get type() {
    return this._type;
  }

  @api set record(val) {
    if (val) {
      this._record = val;
      if (this.type) {
        this.handleMultiSelectInit();
      }
    }
  }
  get record() {
    return this._record;
  }

  @api get propertyObj() {
    return this._propertyObj;
  }

  set propertyObj(value) {
    if (typeof value === "string" && value.charAt(0) === "\\") {
      value = JSON.parse(value.substring(1));
    }
    Promise.resolve().then(() => {
      this._propertyObj = cloneDeep(value);
      this._propertyObj =
        typeof this._propertyObj === "string"
          ? JSON.parse(this._propertyObj)
          : this._propertyObj;
      extractCustomLabelUsed(this.propertyObj)
        .then(labels => {
          this.customLabels = labels ? labels : {};
        })
        .finally(() => {
          if (this._propertyObj.fieldBinding) {
            this._propertyObj.value = this._propertyObj.fieldBinding;
          }
          this.handleMultiSelectInit();
        });
    });
  }

  //Used for setValues
  @api get value() {
    return this._value;
  }
  set value(val) {
    this._value = val ? val : "";
  }

  get isSelected() {
    return (
      this.selectedElement.checkboxgroup ||
      this.selectedElement.pill ||
      this.selectedElement.checkboximagegroup ||
      this.selectedElement.checkboxbutton ||
      this.selectedElement.checkboxgrouphorizontal
    );
  }

  updateStyles() {
    let ele = this.template.querySelector(`[data-type=${this.type}`);
    if (ele) {
      ele.styles = this.styles;
    }
  }

  handleMultiSelectInit() {
    let ele = this.template.querySelector(`[data-type=${this.type}`);
    if (ele) {
      let _record = { ...this.record };
      if (this._allMergeFields) {
        _record = { ..._record, ...this._allMergeFields };
      }
      let interpolatedValue = interpolateKeyValue(
        this.propertyObj,
        _record,
        this._regexPattern
      );
      if (this._propertyObj.fieldBinding) {
        interpolatedValue.value = interpolatedValue.fieldBinding;
      }
      delete interpolatedValue.fieldBinding;
      if (this._allMergeFields) {
        this.interPolatedParentFields = interpolateKeyValue(
          this.propertyObj,
          this._allMergeFields,
          this._regexPattern
        );
      }
      if (!isEqual(this._interpolatedValue, interpolatedValue)) {
        Object.entries(interpolatedValue).forEach(([key, value]) => {
          if (this.excludeKeys.indexOf(key) === -1) {
            value = this.processExtramergeFields(key, value, false);
            value =
              value === "false" || value === "true" ? JSON.parse(value) : value;
            if (key === "options") {
              ele[key] = this.getCustomLabelValueForOptions(value);
            } else {
              const val = this.getCustomLabelValue(value);
              ele[key] =
                key === "value" &&
                this.type === "pill" &&
                typeof val === "string" &&
                val !== ""
                  ? val.split(";")
                  : val;
            }
          }
        });
        if (
          interpolatedValue.customProperties &&
          interpolatedValue.customProperties.length
        ) {
          interpolatedValue.customProperties.forEach(
            (customProperty, index) => {
              if (
                this.excludeKeys.indexOf(customProperty.label) === -1 &&
                customProperty &&
                customProperty.value &&
                customProperty.value !== "null"
              ) {
                let processedExtraMergeField = this.processExtramergeFields(
                  customProperty.label,
                  customProperty.value,
                  true,
                  index
                );
                if (
                  processedExtraMergeField &&
                  typeof processedExtraMergeField !== "string"
                ) {
                  if (processedExtraMergeField.label) {
                    customProperty = processedExtraMergeField;
                  } else {
                    customProperty.value = processedExtraMergeField;
                  }
                }
                let valueToUpdate = customProperty ? customProperty.value : "";
                try {
                  valueToUpdate = JSON.parse(valueToUpdate);
                } catch (e) {
                  valueToUpdate = customProperty ? customProperty.value : "";
                }
                if (
                  customProperty &&
                  customProperty.label.startsWith("data-")
                ) {
                  ele.setAttribute(
                    customProperty.label,
                    this.getCustomLabelValue(valueToUpdate)
                  );
                } else if (customProperty.label === "options") {
                  valueToUpdate = interpolateKeyValue(
                    customProperty.value,
                    this._record
                  );
                  extractCustomLabelUsed(valueToUpdate)
                    .then(labels => {
                      this.customLabels = labels
                        ? { ...this.customLabels, ...labels }
                        : this.customLabels;
                    })
                    .finally(() => {
                      ele[
                        customProperty.label
                      ] = this.getCustomLabelValueForOptions(valueToUpdate);
                    });
                } else {
                  ele[customProperty.label] = this.getCustomLabelValue(
                    valueToUpdate
                  );
                }
              }
            }
          );
        }
        this._interpolatedValue = { ...interpolatedValue };

        if (!ele.label) {
          ele.label = "Label";
        }
      }
    }
  }

  getCustomLabelValue(labelString) {
    let regex = /({|%7B)Label\.(.*?)(}|%7D)/g; //Matching for {Label.<>} || %7BLabel.<>%7D
    let matchedArray =
      (labelString && labelString.match && labelString.match(regex)) || [];
    if (matchedArray.length) {
      let labelArr = matchedArray[0].split(".");
      let customLabel = labelArr[1] && labelArr[1].replace(/(}|%7D)/g, "");
      if (customLabel && this.customLabels[customLabel]) {
        return labelString.replace(
          matchedArray[0],
          this.customLabels[customLabel]
        );
      }
    }

    if (typeof labelString === "string" && labelString.indexOf("{") !== -1) {
      return "";
    }
    return labelString;
  }
  getCustomLabelValueForOptions(options) {
    if (Array.isArray(options)) {
      return options.map(option => {
        return {
          ...option,
          label:
            typeof option.label === "string" && option.label.indexOf("{") !== -1
              ? this.getCustomLabelValue(option.label)
              : option.label,
          value:
            typeof option.value === "string" && option.value.indexOf("{") !== -1
              ? this.getCustomLabelValue(option.value)
              : option.value
        };
      });
    }
    return {};
  }

  processExtramergeFields(key, value, isCustomProperty, index) {
    let regexForParent = /({|%7B)Parent\.(.*?)(}|%7D)/g; //Matching for {Parent.<>} || %7BParent.<>%7D
    let regexForSession = /({|%7B)Session\.(.*?)(}|%7D)/g; //Matching for {Session.<>} || %7BSession.<>%7D
    let matchedArray =
      (value &&
        value.match &&
        (value.match(regexForParent) || value.match(regexForSession))) ||
      [];
    if (matchedArray.length && this.interPolatedParentFields) {
      let extraMergeFieldValue = this.interPolatedParentFields[key];
      if (isCustomProperty) {
        extraMergeFieldValue = this.interPolatedParentFields.customProperties[
          index
        ];
      }
      value = extraMergeFieldValue || value;
    }
    return value;
  }

  triggerInputEvent(evt) {
    if (evt.type === "remove") {
      evt.stopPropagation();
    }
    evt?.currentTarget?.reportValidity();
    this._value = evt.currentTarget && evt.currentTarget.value;
    this._value = Array.isArray(this._value)
      ? this._value.join(";")
      : this._value;
    if (this._propertyObj.fieldBinding) {
      let ele = this.template.querySelector(`[data-type=${this.type}`);

      this.triggerUpdateFieldBinding(this._propertyObj.fieldBinding, null, evt);
      if (ele) {
        this.propertyObj.value = ele.value;
      }
    }
    const elemName = evt?.currentTarget?.name || "name";
    this.eventParams = {
      type: this.type,
      name: elemName,
      value: evt.currentTarget && evt.currentTarget.value,
      checked: evt.currentTarget && evt.currentTarget.checked,
      event: evt
    };
    if (
      evt.currentTarget &&
      evt.currentTarget.dataset &&
      Object.keys(evt.currentTarget.dataset).length
    ) {
      Object.assign(this.eventParams, evt.currentTarget.dataset);
    }

    pubsub.fire(elemName, "baseinputvaluechange", this.eventParams);

    this.dispatchEvent(
      new CustomEvent(
        "baseinputvaluechange",
        {
          type: this.type,
          name: elemName,
          event: evt
        },
        {
          bubbles: true,
          composed: true
        }
      )
    );
  }

  triggerRender() {
    if (this.type) {
      this.handleMultiSelectInit();
    }
  }

  preventKeyDown = event => event.stopPropagation();
}
