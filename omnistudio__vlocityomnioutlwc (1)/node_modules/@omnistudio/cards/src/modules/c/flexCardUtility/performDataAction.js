/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import getDataHandler from "./dataHandler.js";
import { subscribeEMP } from "./streamingChannel";
import { doEncryptedDatasourceFlex, InvalidResponseErrorMessage } from "c/flexCardUtils";

const executeDataAction = (data, callback, debug, timeout) => {
  return new Promise((resolve, reject) => {
    if (data.type === "StreamingAPI") {
      fireStreamingApiAction(data, callback, debug);
      resolve("Streaming Channel Subscribed");
    } else if (data.type === "Custom") {
      let result = JSON.parse(data.value.body);
      resolve(result);
    } else {
      if (timeout > 0) {
        var timer = new Promise(reject => {
          setTimeout(reject, timeout, `Response timed out at ${timeout} ms`);
        });
        var getData = fetchData(data);
        Promise.race([timer, getData])
          .then(_data => {
            let result = typeof _data === "string" ? JSON.parse(_data) : _data;
            resolve(result);
          })
          .catch(e => {
            reject(e);
          });
      } else {
        fetchData(data)
          .then(_data => {
            let result = typeof _data === "string" ? JSON.parse(_data) : _data;
            resolve(result);
          })
          .catch(e => {
            reject(e);
          });
      }
    }
  });
};

const fetchData = data => {
  if (data.OmniUiCardKey && data.elementId) {
    return doEncryptedDatasourceFlex(
      data.OmniUiCardKey,
      data.jsonMap,
      data.elementId
    );
  } else {
    return getDataHandler(JSON.stringify(data));
  }
};

const fireStreamingApiAction = (data, callback, debug) => {
  let dsObject = { ...data };
  let channelName = dsObject.value.channel;
  let replayId = dsObject.value.replayAll === "true" ? -2 : -1;
  subscribeEMP(channelName, replayId, callback, debug);
};

const dataActionUpdateRecords = obj => {
  return new Promise((resolve, reject) => {
    let records;
    let response = obj.response;
    let index = obj.index;
    let responseNode = obj.node;
    switch (responseNode) {
      case "record":
        let data = response;
        if (typeof response === "string") {
          try {
            data = JSON.parse(response);
          } catch (e) {
            reject(InvalidResponseErrorMessage);
          }
        }
        if (obj.records && data && !Array.isArray(data)) {
          records = [...obj.records];
          let record = records[index];
          if (record) {
            records[index] = { ...record, ...response };
          }
        } else {
          reject("Invalid Response");
        }
        break;
      default:
        records = [...obj.records];
        if (records && records[index]) {
          records[index][responseNode] = validObj(response);
        }
        break;
    }
    resolve(records);
  });
};

function validObj(val, type) {
  if (typeof val === "string") {
    try {
      let obj = JSON.parse(val);
      return !Array.isArray(obj) && type === "array" ? [obj] : obj;
    } catch (e) {
      return type === "array" ? [] : {};
    }
  }
  return val;
}

export { executeDataAction, dataActionUpdateRecords };
