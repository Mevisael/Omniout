/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { get } from "c/lodash";

const reserverFlexVariables = ["Flex.index"];

function groupFilter(group, obj, context, evaluatedCondition) {
  let conditionEval;
  if (typeof evaluatedCondition === "boolean") {
    conditionEval = evaluatedCondition;
  }
  group.forEach(condition => {
    condition = {
      ...condition
    };
    if (condition.group) {
      conditionEval = handleConditionGroup(
        condition,
        conditionEval,
        obj,
        context
      );
    }
    if (condition.operator) {
      conditionEval = handleOperator(condition, conditionEval, obj, context);
    }
  });
  return conditionEval;
}

function getFlag(condition, realVal) {
  switch (condition.operator) {
    case "==":
      // eslint-disable-next-line eqeqeq
      return realVal == condition.value;
    case ">":
      return realVal !== "undefined" && realVal > condition.value;
    case "<":
      return realVal !== "undefined" && realVal < condition.value;
    case ">=":
      return realVal !== "undefined" && realVal >= condition.value;
    case "<=":
      return realVal !== "undefined" && realVal <= condition.value;
    case "!=":
      // eslint-disable-next-line eqeqeq
      return realVal != condition.value;
    default:
      return undefined;
  }
}

function handleConditionGroup(condition, conditionEval, obj, context) {
  let evaluatedCondition = groupFilter(
    condition.group,
    obj,
    context,
    conditionEval
  );
  if (condition.logicalOperator) {
    evaluatedCondition = evaluateCondition(
      conditionEval,
      condition.logicalOperator,
      evaluatedCondition
    );
  }
  return evaluatedCondition;
}

function handleOperator(condition, conditionEval, obj, context) {
  // Special case to compare Flex private variable for each record within card. Make sure we dont update reserved variables.
  if (
    condition.field.indexOf("Flex.") === 0 &&
    reserverFlexVariables.indexOf(condition.field) === -1
  ) {
    // For eg: Flex.expand
    condition.field = condition.field + "." + obj.uniqueKey; // This makes it store and compare value unique for each record.
  }
  let realVal =
    condition.field.indexOf("{") === -1 && condition.hasMergeField
      ? condition.field
      : get(obj, condition.field);
  if (condition.field.indexOf("$scope") > -1) {
    realVal =
      get(context, condition.field.substr(7)) ||
      context[condition.field.substr(7)];
  }

  // Special cases
  realVal = typeof realVal === "boolean" ? realVal.toString() : realVal;
  realVal = typeof realVal === "undefined" ? "undefined" : realVal;
  condition.value =
    condition.value && condition.value.toLowerCase() === "null"
      ? null
      : condition.value;

  // End Special cases
  if (condition && condition.value && !isNaN(condition.value)) {
    condition.value = parseFloat(condition.value);
  }
  const flag = getFlag(condition, realVal);
  if (typeof conditionEval === "boolean" && condition.logicalOperator) {
    return evaluateCondition(conditionEval, condition.logicalOperator, flag);
  }
  return flag;
}

function evaluateCondition(leftCondtion, conditionalOperator, rightCondition) {
  return conditionalOperator === "&&"
    ? leftCondtion && rightCondition
    : leftCondtion || rightCondition;
}

export { groupFilter };
