/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { LightningElement, track, api } from "lwc";
import { BaseFlexElementMixin } from "c/baseFlexElementMixin";
import { cloneDeep, findIndex } from "c/lodash";
import { interpolateKeyValue, extractCustomLabelUsed } from "c/flexCardUtility";
import pubsub from "c/pubsub";

const DEFAULT_RADIO_TYPE = "radiogroup";
export default class FlexRadioInput extends BaseFlexElementMixin(
  LightningElement
) {
  _propertyObj = {};
  _pubsubEvent = {};
  _regexPattern = /\{([a-zA-Z.0-9_]*)\}/g; //for {} fields by default
  excludeKeys = [
    "card",
    "propertyObj",
    "record",
    "recordId",
    "customProperties",
    "radioDisplayValue"
  ];

  @api set card(val) {
    if (val) {
      this._card = val;
      this.initMergeFields(val);
    }
  }
  get card() {
    return this._card;
  }

  @track _type = "";
  @api theme;
  @api obj;
  @api element;
  @api action;
  @api extraclass;
  @track _card;
  _alignment = "vertical";
  _radioGroupType = "radio";
  customLabels = {};
  _value;

  //Used for setValues
  @api get value() {
    return this._value;
  }
  set value(val) {
    this._value = val ? val : "";
  }

  //Getter and Setter Methods
  @api get propertyObj() {
    return this._propertyObj;
  }
  set propertyObj(value) {
    if (typeof value === "string" && value.charAt(0) === "\\") {
      value = JSON.parse(value.substring(1));
    }
    this._propertyObj = cloneDeep(value);
    this._propertyObj =
      typeof this._propertyObj === "string"
        ? JSON.parse(this._propertyObj)
        : this._propertyObj;
    extractCustomLabelUsed(this.propertyObj)
      .then(labels => {
        this.customLabels = labels ? labels : {};
      })
      .finally(() => {
        if (this._propertyObj.fieldBinding) {
          this._propertyObj.value = this._propertyObj.fieldBinding;
        }
        this.init();
      });
  }

  @api set styles(val) {
    if (val) {
      this._styles = val;
      Promise.resolve().then(() => {
        this.updateStyles();
      });
    }
  }
  get styles() {
    return this._styles;
  }

  @api set type(val) {
    if (val && typeof val === "string") {
      const radioType = val.split(".");
      this._type =
        radioType && radioType.length ? radioType[0] : DEFAULT_RADIO_TYPE;
      this.selectedRadioDisplayMode[this.type] = true;
      this.setAlignment(radioType[1]);
    }
  }
  get type() {
    return this._type;
  }

  @api set record(val) {
    if (val) {
      this._record = val;
      if (this.type) {
        this.init();
      }
    }
  }
  get record() {
    return this._record;
  }

  @track selectedRadioDisplayMode = {};
  @track _interpolatedProperyObj = {};

  connectedCallback() {
    this._interpolatedProperyObj.label =
      this._propertyObj && this._propertyObj.label
        ? this._propertyObj.label
        : "Label";
    this._interpolatedProperyObj.options =
      this._propertyObj && this._propertyObj.options
        ? this._propertyObj.options
        : [];
  }

  /**
   * @description Set the alignment of the radio group.
   * @param {String} alignment
   * @returns {void}
   * @scope private
   */
  setAlignment(alignment) {
    if (alignment === "button") {
      this._radioGroupType = alignment;
    } else {
      this._alignment = alignment ? alignment : this._alignment;
    }
  }

  /**
   * @description Set default properties on the interpolated object
   * @param {Object} interpolatedValue - interpolated property object
   * @returns {void}
   * @scope private
   */
  setDefaultProperties(interpolatedValue) {
    if (
      !Object.hasOwnProperty.call(interpolatedValue, "value") &&
      interpolatedValue.options &&
      interpolatedValue.options.length
    ) {
      const selectedOption = interpolatedValue.options.find(
        opt => opt.selected
      );
      interpolatedValue.value = selectedOption ? selectedOption.value : "";
    }
  }

  /**
   * @description Initialize the component
   * @returns {void}
   * @scope private
   */
  init() {
    let ele;
    let _record = { ...this.record };
    if (this._allMergeFields) {
      _record = { ..._record, ...this._allMergeFields };
    }
    let interpolatedValue = interpolateKeyValue(
      this.propertyObj,
      _record,
      this._regexPattern
    );
    if (this._allMergeFields) {
      this.interPolatedParentFields = interpolateKeyValue(
        this.propertyObj,
        this._allMergeFields,
        this._regexPattern
      );
    }
    this.setDefaultProperties(interpolatedValue);
    Object.entries(interpolatedValue).forEach(([key, value]) => {
      value = this.processExtramergeFields(key, value, false);
      value = value === "false" || value === "true" ? JSON.parse(value) : value;
      if (key === "options") {
        value = this.getCustomLabelValueForOptions(value);
      } else {
        value = this.getCustomLabelValue(value);
      }
      this._interpolatedProperyObj[key] =
        key === "value" ? value.toString() : value;
    });
    const radioType = this.type || DEFAULT_RADIO_TYPE;
    ele = this.template.querySelector(`[data-type=${radioType}`);
    if (
      ele &&
      interpolatedValue.customProperties &&
      interpolatedValue.customProperties.length
    ) {
      interpolatedValue.customProperties.forEach((customProperty, index) => {
        if (
          this.excludeKeys.indexOf(customProperty.label) === -1 &&
          customProperty &&
          customProperty.value &&
          customProperty.value !== "null"
        ) {
          customProperty.value =
            customProperty.label === "options" &&
            Array.isArray(customProperty.value)
              ? interpolateKeyValue(customProperty.value, this._record)
              : customProperty.value;
          let processedExtraMergeField = this.processExtramergeFields(
            customProperty.label,
            customProperty.value,
            true,
            index
          );
          if (
            processedExtraMergeField &&
            typeof processedExtraMergeField !== "string"
          ) {
            if (processedExtraMergeField.label) {
              customProperty = processedExtraMergeField;
            } else {
              customProperty.value = processedExtraMergeField;
            }
          }
          let valueToUpdate = customProperty ? customProperty.value : "";
          try {
            valueToUpdate = JSON.parse(valueToUpdate);
          } catch (e) {
            valueToUpdate = customProperty ? customProperty.value : "";
          }
          if (customProperty && customProperty.label.startsWith("data-")) {
            ele.setAttribute(
              customProperty.label,
              this.getCustomLabelValue(valueToUpdate)
            );
          } else {
            if (customProperty.label === "options") {
              //Extract custom labels used in value of options custom property
              extractCustomLabelUsed(valueToUpdate)
                .then(labels => {
                  this.customLabels = labels
                    ? { ...this.customLabels, ...labels }
                    : this.customLabels;
                })
                .finally(() => {
                  const updatedValue = this.getCustomLabelValueForOptions(
                    valueToUpdate
                  );
                  this.updateValue(ele, customProperty.label, updatedValue);
                });
            } else {
              const updatedValue = this.getCustomLabelValue(valueToUpdate);
              this.updateValue(ele, customProperty.label, updatedValue);
            }
          }
        }
      });
    }
  }

  /**
   * @description Update the proprties of the element
   * @param {Object} element
   * @param {String} label
   * @param {Any} value
   * @returns {void}
   * @scope private
   **/
  updateValue(element, label, value) {
    if (Object.hasOwnProperty.call(this._interpolatedProperyObj, label)) {
      this._interpolatedProperyObj[label] = value;
    }
    if (element && label) {
      element[label] = value;
    }
  }

  /**
   * @description Get custom label values for options array
   * @param {Array} options
   * @returns {void}
   * @scope private
   **/
  getCustomLabelValueForOptions(options) {
    if (Array.isArray(options)) {
      return options.map(option => {
        return {
          ...option,
          label:
            typeof option.label === "string" && option.label.indexOf("{") !== -1
              ? this.getCustomLabelValue(option.label)
              : option?.label?.toString(),
          value:
            typeof option.value === "string" && option.value.indexOf("{") !== -1
              ? this.getCustomLabelValue(option.value)
              : option?.value?.toString()
        };
      });
    }
    return [];
  }

  /**
   * @description Get custom label values
   * @param {String} labelString
   * @returns {void}
   * @scope private
   */
  getCustomLabelValue(labelString) {
    let regex = /({|%7B)Label\.(.*?)(}|%7D)/g; //Matching for {Label.<>} || %7BLabel.<>%7D
    let matchedArray =
      (labelString && labelString.match && labelString.match(regex)) || [];
    if (matchedArray.length) {
      let labelArr = matchedArray[0].split(".");
      let customLabel = labelArr[1] && labelArr[1].replace(/(}|%7D)/g, "");
      if (customLabel && this.customLabels[customLabel]) {
        return labelString.replace(
          matchedArray[0],
          this.customLabels[customLabel]
        );
      }
    }
    return labelString;
  }

  /**
   * @description Set styles
   * @returns {void}
   * @scope private
   */
  updateStyles() {
    let ele = this.template.querySelector(`[data-type=${this.type}`);
    if (ele) {
      ele.styles = this.styles;
    }
  }

  /**
   * @description Process the merge Fields
   * @param {String} key - key of property object
   * @param {Any} value - value of a key in property object
   * @param {Boolean} isCustomProperty
   * @param {Number} index
   * @returns {void}
   * @scope private
   */
  processExtramergeFields(key, value, isCustomProperty, index) {
    let regexForParent = /({|%7B)Parent\.(.*?)(}|%7D)/g; //Matching for {Parent.<>} || %7BParent.<>%7D
    let regexForSession = /({|%7B)Session\.(.*?)(}|%7D)/g; //Matching for {Session.<>} || %7BSession.<>%7D
    let matchedArray =
      (value &&
        value.match &&
        (value.match(regexForParent) || value.match(regexForSession))) ||
      [];
    if (matchedArray.length && this.interPolatedParentFields) {
      let extraMergeFieldValue = this.interPolatedParentFields[key];
      if (isCustomProperty) {
        extraMergeFieldValue = this.interPolatedParentFields.customProperties[
          index
        ];
      }
      value = extraMergeFieldValue || value;
    }
    return value;
  }

  /**
   * @description Trigger event
   * @param {Event} evt
   * @returns {void}
   * @scope private
   */
  triggerInputEvent(evt) {
    let label = "";
    const value = evt.currentTarget && evt.currentTarget.value;
    const checked = evt.currentTarget && evt.currentTarget.checked;
    const eventName = "baseinputvaluechange";
    const eleName = evt.currentTarget && evt.currentTarget.name;
    this._value = value;
    if (evt?.currentTarget?.options) {
      let index = findIndex(
        evt.currentTarget.options,
        // eslint-disable-next-line eqeqeq
        x => x.value == value
      );
      label = evt.currentTarget.options[index].label;
    }

    if (this._propertyObj.fieldBinding) {
      this.triggerUpdateFieldBinding(this._propertyObj.fieldBinding, null, evt);
    }

    this.eventParams = {
      type: this.type,
      name: eleName,
      label: label,
      value: value,
      checked: checked,
      event: evt
    };
    if (
      evt?.currentTarget?.dataset &&
      Object.keys(evt.currentTarget.dataset).length
    ) {
      Object.assign(this.eventParams, evt.currentTarget.dataset);
    }
    pubsub.fire(eleName, eventName, this.eventParams);
  }

  /**
   * @description Hook to render element
   * @returns {void}
   */
  triggerRender() {
    if (this.type) {
      this.init();
    }
  }
}
