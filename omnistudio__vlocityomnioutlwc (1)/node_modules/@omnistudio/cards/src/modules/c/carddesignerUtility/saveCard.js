/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { saveCard, saveCardPublish } from "c/flexCardUtils";
import { getAllCards } from "./getAllCards";
import { setCardById, getCardDataById } from "./getCard";
import { getCardObjectFields } from "./getCardObjectFields";
import { getErrorMessage, unEscape } from "./carddesignerUtility";
import pubsub from "c/pubsub";

let showToast = (msg, title, type, recordId) => {
  pubsub.fire(`card:${recordId}:header`, "showtoast", {
    message: unEscape(msg),
    title: title,
    type: type
  });
};

let errors = [];
let adaptLayoutJsonForSave = json => {
  let cardObjectFields = getCardObjectFields(json);
  return Object.keys(json).reduce(function(outputObject, key) {
    if (
      /(^Id|^Name|^LastModifiedDate|__c)$/.test(key) ||
      key in cardObjectFields ||
      Object.values(cardObjectFields).includes(key)
    ) {
      outputObject[key] = json[key];
    }
    return outputObject;
  }, {});
};

//This is only required while creating new card/ card version /clone
//pass isNew as true for this check
let shouldSave = (item, json) => {
  if (item.isNew) {
    let cardObjectFields = getCardObjectFields(item);
    //parse definition if it comes in as string
    item[cardObjectFields.PropertySetConfig] =
      typeof item[cardObjectFields.PropertySetConfig] === "string"
        ? JSON.parse(item[cardObjectFields.PropertySetConfig])
        : item[cardObjectFields.PropertySetConfig];
    return new Promise(function(resolve, reject) {
      // check card name doesn't exist already
      return getAllCards().then(cards => {
        if (
          cards.find(function(card) {
            return (
              card.Name === item.Name &&
              card[cardObjectFields.AuthorName] ===
                item[cardObjectFields.AuthorName] &&
              card[cardObjectFields.VersionNumber] ===
                item[cardObjectFields.VersionNumber] &&
              card.Id !== item.Id
            );
          })
        ) {
          if (item.originalJson) {
            if (
              item.Name !== item.originalJson.Name &&
              (item[cardObjectFields.AuthorName] !==
                item.originalJson[cardObjectFields.AuthorName] ||
                item[cardObjectFields.VersionNumber] !==
                  item.originalJson[cardObjectFields.VersionNumber])
            ) {
              //make sure the name changed to a used name
              errors.push({
                message: "This name is already in use"
              });
            }
          } else {
            errors.push({
              message: "This name is already in use"
            });
          }
          reject(errors);
        }
        if (!item[cardObjectFields.AuthorName]) {
          errors.push({
            message: "Please provide a Card author"
          });
          reject(errors);
        }
        //check filter field key is not empty
        if (
          item[cardObjectFields.PropertySetConfig] &&
          item[cardObjectFields.PropertySetConfig].filter &&
          item[cardObjectFields.PropertySetConfig].filter.length
        ) {
          item[cardObjectFields.PropertySetConfig].filter.forEach(
            item[cardObjectFields.PropertySetConfig].filter,
            (value, key) => {
              if (key === "" || value === "") {
                errors.push({
                  message: "Please provide a Card filter key and value"
                });
                reject(errors);
              }
            }
          );
        }
        if (
          item[cardObjectFields.PropertySetConfig] &&
          item[cardObjectFields.PropertySetConfig].states &&
          item[cardObjectFields.PropertySetConfig].states.length === 0
        ) {
          errors.push({
            message: "Please provide a Card State"
          });
          reject(errors);
        }
        if (
          item[cardObjectFields.PropertySetConfig] &&
          item[cardObjectFields.PropertySetConfig].states &&
          item[cardObjectFields.PropertySetConfig].states.length > 0
        ) {
          item[cardObjectFields.PropertySetConfig].states.forEach(state => {
            if (
              !(
                state.name ||
                state.templateUrl ||
                (state.lwc && state.lwc.DeveloperName)
              )
            ) {
              errors.push({
                message:
                  "Please provide a Card State name and template/component"
              });
              reject(errors);
            }
          });
        }
        //locked card
        if (item.locked) {
          reject(new Error("locked card"));
        }
        item.originalJson = json;
        item.saving = true;
        item.errors = null;
        resolve(item);
      });
    });
  }
  return new Promise(function(resolve) {
    resolve();
  });
};
async function saveLwcCard(card, publish, newCardJson, asyncSave) {
  try {
    var jsonToSave = adaptLayoutJsonForSave(card);
    await shouldSave(card, jsonToSave);
    delete card.isNew;
    let cardObjectFields = getCardObjectFields(card);
    if (jsonToSave[cardObjectFields.DataSourceConfig]) {
      jsonToSave[cardObjectFields.DataSourceConfig] =
        typeof jsonToSave[cardObjectFields.DataSourceConfig] === "object"
          ? JSON.stringify(jsonToSave[cardObjectFields.DataSourceConfig])
          : jsonToSave[cardObjectFields.DataSourceConfig];
    }
    if (jsonToSave.LastModifiedDate) {
      delete jsonToSave.LastModifiedDate;
    }
    let obj = {
      card: jsonToSave
    };

    if (asyncSave) {
      const newJson = newCardJson ? newCardJson : jsonToSave;
      setCardById(jsonToSave.Id, newJson);
      fireSaveCard(obj, jsonToSave.Id, publish, newCardJson, true);
      return newJson;
    } else {
      return fireSaveCard(obj, jsonToSave.Id, publish, newCardJson, false);
    }
  } catch (error) {
    const errMsg =
      new Error("Unable to save the card : ") + getErrorMessage(error);
    if (jsonToSave?.Id) {
      showToast(errMsg, "Error!", "error", jsonToSave.Id);
    }
    return Promise.reject(errMsg);
  }
}

async function fireSaveCard(obj, cardId, publish, newCardJson, asyncSave) {
  try {
    const updatedCard = await (publish ? saveCardPublish(obj) : saveCard(obj));
    const newJson = newCardJson ? newCardJson : updatedCard;
    if (!asyncSave) {
      setCardById(cardId, newJson);
    }
    return newJson;
  } catch (error) {
    const errMsg = ` Unable to save the card : ${getErrorMessage(error)}`;
    showToast(errMsg, "Error!", "error", cardId);
    if (asyncSave) {
      const cardData = await getCardDataById(cardId, true);
      setCardById(cardId, cardData);
    } else {
      return Promise.reject(errMsg);
    }
  }
}

export default saveLwcCard;
