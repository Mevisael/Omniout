/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { LightningElement, api, track } from "lwc";
import { findIndex, isEqual, cloneDeep } from "c/lodash";
import { BaseFlexElementMixin } from "c/baseFlexElementMixin";
import { interpolateKeyValue, extractCustomLabelUsed } from "c/flexCardUtility";
import pubsub from "c/pubsub";
import { parseChronoAttributes } from "./baseInputElementLibrary";

export default class CustomLwc extends BaseFlexElementMixin(LightningElement) {
  _propertyObj = {};
  _regexPattern = /\{([a-zA-Z.0-9_]*)\}/g; //for {} fields by default
  _interpolatedValue = {};
  excludeKeys = [
    "card",
    "propertyObj",
    "record",
    "recordId",
    "customProperties",
    "imask"
  ];
  _maskProperties = {};
  customLabels = {};
  previousValue = null;
  @track _type = "";
  @api theme;
  @api obj;
  @api element;
  @api action;
  @api extraclass;

  @api set styles(val) {
    if (val) {
      this._styles = val;
      Promise.resolve().then(() => {
        this.updateStyles();
      });
    }
  }
  get styles() {
    return this._styles;
  }

  @api set type(val) {
    if (val) {
      this._type = val;
      this.selectedElement[this.type] = true;
    }
  }
  get type() {
    return this._type;
  }

  @api set record(val) {
    if (val) {
      this._record = val;
      if (this.type) {
        this.handleBaseInputElementInit();
      }
    }
  }
  get record() {
    return this._record;
  }

  triggerRender() {
    if (this.type) {
      this.handleBaseInputElementInit();
    }
  }

  @track selectedElement = {};

  //Getter and Setter Methods
  @api get propertyObj() {
    return this._propertyObj;
  }
  set propertyObj(value) {
    if (typeof value === "string" && value.charAt(0) === "\\") {
      value = JSON.parse(value.substring(1));
    }
    this._propertyObj = cloneDeep(value);
    this._propertyObj =
      typeof this._propertyObj === "string"
        ? JSON.parse(this._propertyObj)
        : this._propertyObj;
    extractCustomLabelUsed(this.propertyObj)
      .then(labels => {
        this.customLabels = labels ? labels : {};
      })
      .finally(() => {
        if (this._propertyObj.fieldBinding) {
          this._propertyObj.value = this._propertyObj.fieldBinding;
          if (this.selectedElement.checkbox) {
            this._propertyObj.checked = this._propertyObj.fieldBinding;
          }
        }
        this.handleBaseInputElementInit();
      });
  }

  _value;
  _checked;
  timeInputValue = "";

  //Used for setValues
  @api get value() {
    return this._value;
  }
  set value(val) {
    this._value = val ? val : "";
  }

  //Used for setValues
  @api get checked() {
    return this._checked;
  }
  set checked(val) {
    this._checked = val;
  }

  updateStyles() {
    let ele = this.template.querySelector(`[data-type=${this.type}`);
    if (ele) {
      ele.styles = this.styles;
    }
  }

  parseDateFields(interpolatedObj, key, value) {
    if (key === "min" || key === "max") {
      interpolatedObj[key] = parseChronoAttributes(value, key);
    }
    if (key === "value") {
      interpolatedObj[key] = parseChronoAttributes(value);
    }
    if (
      this.type !== "time" &&
      (key === "format" || key === "dateFormat" || key === "outputFormat") &&
      typeof value === "string"
    ) {
      interpolatedObj[key] = value.toUpperCase();
    }
  }

  handleBaseInputElementInit() {
    this.previousValue = null;
    let ele = this.template.querySelector(`[data-type=${this.type}`);
    let _record = { ...this.record };
    if (ele) {
      if (this._allMergeFields) {
        _record = { ..._record, ...this._allMergeFields };
      }
      if (this.type === "datetime") {
        this._propertyObj.dateLabel = this._propertyObj.dateLabel || "";
        this._propertyObj.timeLabel = this._propertyObj.timeLabel || "";
        this._propertyObj.datePlaceholder =
          this._propertyObj.datePlaceholder || "";
        this._propertyObj.timePlaceholder =
          this._propertyObj.timePlaceholder || "";
      }
      let interpolatedValue = interpolateKeyValue(
        this.propertyObj,
        _record,
        this._regexPattern
      );
      delete interpolatedValue.fieldBinding;
      if (!isEqual(this._interpolatedValue, interpolatedValue)) {
        if (this.showInput) {
          ele.type = this.type;
        }
        Object.entries(interpolatedValue).forEach(([key, value]) => {
          if (this.excludeKeys.indexOf(key) === -1) {
            value = this.processExtramergeFields(key, value, false);
            if (
              (this.selectedElement.pill || this.selectedElement.typeahead) &&
              key === "options" &&
              value &&
              value.length
            ) {
              ele[key] = value.map(a => a.value);
            } else {
              if (
                this.type === "date" ||
                this.type === "datetime" ||
                this.type === "time"
              ) {
                this.parseDateFields(interpolatedValue, key, value);
                value = interpolatedValue[key];
              }
              value =
                value === "false" || value === "true"
                  ? JSON.parse(value)
                  : value;

              value =
                key === "options"
                  ? this.getCustomLabelValueForOptions(value)
                  : key === "styles"
                  ? value
                  : this.getCustomLabelValue(value);
              if (!(value == null || value === "null")) {
                ele[key] = value;
                if (key === "value" && this.type === "time") {
                  this.timeInputValue = value;
                }
              }
            }
          }
        });
        if (
          interpolatedValue.customProperties &&
          interpolatedValue.customProperties.length
        ) {
          interpolatedValue.customProperties.forEach(
            (customProperty, index) => {
              if (
                this.excludeKeys.indexOf(customProperty.label) === -1 &&
                customProperty &&
                customProperty.value !== "null"
              ) {
                let processedExtraMergeField = this.processExtramergeFields(
                  customProperty.label,
                  customProperty.value,
                  true,
                  index
                );
                if (
                  processedExtraMergeField &&
                  typeof processedExtraMergeField !== "string"
                ) {
                  if (processedExtraMergeField.label) {
                    customProperty = processedExtraMergeField;
                  } else {
                    customProperty.value = processedExtraMergeField;
                  }
                }
                let valueToUpdate = customProperty ? customProperty.value : "";
                try {
                  valueToUpdate = JSON.parse(valueToUpdate);
                } catch (e) {
                  valueToUpdate = customProperty ? customProperty.value : "";
                }

                if (
                  customProperty &&
                  customProperty.label.startsWith("data-")
                ) {
                  let datasetValue = this.getCustomLabelValue(valueToUpdate);
                  if (datasetValue === "{record}") {
                    datasetValue = this.record;
                  }
                  if (typeof datasetValue === "object") {
                    datasetValue = JSON.stringify(datasetValue);
                  }
                  ele.setAttribute(customProperty.label, datasetValue);
                } else {
                  let finalValueToUpdate = this.getCustomLabelValue(
                    valueToUpdate
                  );
                  if (
                    finalValueToUpdate &&
                    typeof finalValueToUpdate === "string" &&
                    finalValueToUpdate.charAt(0) === "{"
                  ) {
                    return;
                  }
                  if (
                    !(
                      finalValueToUpdate == null ||
                      finalValueToUpdate === "null"
                    )
                  ) {
                    if (customProperty.label === "mask") {
                      let propObj = this.propertyObj;
                      propObj.imask = valueToUpdate;
                      this.propertyObj = { ...propObj };
                      return;
                    }
                    ele[customProperty.label] = finalValueToUpdate;
                    if (
                      customProperty.label === "value" &&
                      this.type === "time"
                    ) {
                      this.timeInputValue = value;
                    }
                  }
                }
              }
            }
          );
          if (this._type !== "range") ele.type = this._type;
        }
        if (!ele.label) {
          ele.label = "Label";
        }
        this._interpolatedValue = { ...interpolatedValue };
      }
      Promise.resolve().then(() => {
        if (this.type === "time") {
          ele.value = this.timeInputValue;
        }
      });
    }
  }

  getCustomLabelValue(labelString) {
    try {
      let regex = /({|%7B)Label\.(.*?)(}|%7D)/g; //Matching for {Label.<>} || %7BLabel.<>%7D
      let matchedArray =
        (labelString && labelString.match && labelString.match(regex)) || [];
      if (matchedArray && matchedArray.length) {
        let labelArr = matchedArray[0].split(".");
        let customLabel = labelArr[1] && labelArr[1].replace(/(}|%7D)/g, "");
        if (customLabel && this.customLabels[customLabel]) {
          return labelString.replace(
            matchedArray[0],
            this.customLabels[customLabel]
          );
        }
      }
      if (typeof labelString === "string" && labelString.indexOf("{") === 0) {
        return "";
      }
    } catch (error) {
      console.error("Error in getCustomLabelValue : ", error);
    }
    return labelString;
  }
  getCustomLabelValueForOptions(options) {
    if (Array.isArray(options)) {
      return options.map(option => {
        return {
          ...option,
          label:
            typeof option.label === "string" && option.label.indexOf("{") !== -1
              ? this.getCustomLabelValue(option.label)
              : option.label,
          value:
            typeof option.value === "string" && option.value.indexOf("{") !== -1
              ? this.getCustomLabelValue(option.value)
              : option.value
        };
      });
    }
  }

  processExtramergeFields(key, value, isCustomProperty, index) {
    let regexForParent = /({|%7B)Parent\.(.*?)(}|%7D)/g; //Matching for {Parent.<>} || %7BParent.<>%7D
    let regexForSession = /({|%7B)Session\.(.*?)(}|%7D)/g; //Matching for {Session.<>} || %7BSession.<>%7D
    let matchedArray =
      (value &&
        value.match &&
        (value.match(regexForParent) || value.match(regexForSession))) ||
      [];
    if (matchedArray.length && this.interPolatedParentFields) {
      let extraMergeFieldValue = this.interPolatedParentFields[key];
      if (isCustomProperty) {
        extraMergeFieldValue = this.interPolatedParentFields.customProperties[
          index
        ];
      }
      value = extraMergeFieldValue || value;
    }
    return value;
  }

  triggerInputEvent(evt) {
    let label = "";
    let value = this.selectedElement.textarea
      ? evt.currentTarget?.htmlFormattedValue
      : evt.currentTarget?.value;
    const checked = evt.currentTarget && evt.currentTarget.checked;
    let eventName = "baseinputvaluechange";
    const eleName = evt?.currentTarget?.name || "name";
    let valueToCompare = value;
    if (this._propertyObj.fieldBinding) {
      this.triggerUpdateFieldBinding(
        this._propertyObj.fieldBinding,
        this.selectedElement.checkbox
          ? "{element.checked}"
          : this.selectedElement.textarea
          ? "{element.htmlFormattedValue}"
          : null,
        evt
      );
    }
    if (this.selectedElement.checkbox && typeof checked !== "undefined") {
      this._propertyObj.checked = checked;
      valueToCompare = checked;
    } else if (this.selectedElement.typeahead && evt.type === "input") {
      eventName = "basetypeaheadinputchange";
      value = this.template.querySelector(".typeahead").value;
    } else if (
      this.type === "combobox" &&
      evt.currentTarget &&
      typeof value === "string"
    ) {
      const index = findIndex(
        evt.currentTarget.options,
        // eslint-disable-next-line eqeqeq
        x => x.value == value
      );
      label = evt.currentTarget.options[index].label;
    }
    if (this.selectedElement.typeahead || this.selectedElement.date) {
      evt?.currentTarget?.reportValidity();
    }
    this.eventParams = {
      type: this.type,
      name: eleName,
      label: label ? label : this._propertyObj.label,
      value,
      checked,
      event: evt
    };
    if (
      evt.currentTarget &&
      evt.currentTarget.dataset &&
      Object.keys(evt.currentTarget.dataset).length
    ) {
      Object.assign(this.eventParams, evt.currentTarget.dataset);
    }
    if (this.previousValue === valueToCompare && this.showInput) {
      return;
    }
    if (typeof checked !== "undefined") {
      this._checked = valueToCompare;
    }
    this._value = valueToCompare;
    this.previousValue = valueToCompare;
    pubsub.fire(eleName, eventName, this.eventParams);
  }

  get showInput() {
    if (
      !(
        this.selectedElement.combobox ||
        this.selectedElement.radiogroup ||
        this.selectedElement.checkboxgroup ||
        this.selectedElement.textarea ||
        this.selectedElement.pill ||
        this.selectedElement.radioimagegroup ||
        this.selectedElement.checkboximagegroup ||
        this.selectedElement.radiocolorpickgroup ||
        this.selectedElement.typeahead ||
        this.showMaskedInput ||
        this.showNumberInput ||
        this.selectedElement.range
      )
    ) {
      return true;
    }
    return false;
  }

  get showMaskedInput() {
    return (
      this.selectedElement.currency ||
      (this.selectedElement.number &&
        this.propertyObj &&
        this.propertyObj.imask) ||
      (this.selectedElement.text &&
        this.propertyObj &&
        this.propertyObj.imask) ||
      (this.selectedElement.tel && this.propertyObj && this.propertyObj.imask)
    );
  }

  get showNumberInput() {
    return (
      this.selectedElement.number && this.propertyObj && !this.propertyObj.imask
    );
  }
  get imaskAttributes() {
    let imaskAttributes = null;
    let mask = this.propertyObj.imask;
    if (mask && (this._type === "text" || this._type === "tel")) {
      imaskAttributes = {
        mask: mask,
        numberMask: this._type === "number" ? true : false,
        definitions: {
          A: /^[A-Za-z]/,
          9: /^[0-9]/
        }
      };
    } else if (this._type === "number" || this._type === "range") {
      this.prepareIMaskProperties(mask);
      let minValue = null;
      let maxValue = null;
      if (!isNaN(this._maskProperties.min)) {
        minValue = this._maskProperties.min;
      }
      if (!isNaN(this._maskProperties.max)) {
        maxValue = this._maskProperties.max;
      }

      imaskAttributes = {
        numberMask: true,
        // eslint-disable-next-line no-new-wrappers
        mask: Number,
        padFractionalZeros: this._maskProperties.padFractionalZeros,
        radix: this._maskProperties.radix,
        scale: this._maskProperties.scale,
        signed: true,
        thousandsSeparator: this._maskProperties.thousandsSeparator,
        min: minValue,
        max: maxValue
      };
    }
    return imaskAttributes;
  }
  prepareIMaskProperties(mask) {
    mask = mask == null ? "" : mask;
    this._maskProperties.radix = ".";
    if (typeof mask === "number" || mask.lastIndexOf(".") !== -1) {
      this._isMasked = true;
      this._maskProperties.scale =
        typeof mask === "number"
          ? mask
          : mask.substring(mask.lastIndexOf(".") + 1).length;
      this._maskProperties.padFractionalZeros = mask === 0 ? false : true;
    } else if (!mask) {
      this._maskProperties.scale = 1000;
      this._maskProperties.padFractionalZeros = false;
    } else {
      this._isMasked = true;
      this._maskProperties.radix = ",";
    }
    this._maskProperties.thousandsSeparator = this.findThousandsSeparator(mask);
    const max = this.fetchCustomPropertyByLabel("max");
    if (max) {
      this._maskProperties.max = max;
    }
    const min = this.fetchCustomPropertyByLabel("min");
    if (min) {
      this._maskProperties.min = min;
    }
  }

  fetchCustomPropertyByLabel(label) {
    if (this._propertyObj?.customProperties?.length) {
      const itemIndex = findIndex(
        this._propertyObj.customProperties,
        x => x.label === label
      );
      if (itemIndex > -1) {
        return this._propertyObj.customProperties[itemIndex].value;
      }
    }
    return null;
  }

  findThousandsSeparator(mask) {
    var i, chr;

    for (i = 1; i < mask.length; i++) {
      chr = mask.charAt(i);

      if (
        mask.indexOf(chr) === i &&
        mask.indexOf(chr, i + 1) === -1 &&
        chr !== "."
      ) {
        return chr;
      }
    }

    return typeof mask === "number" ? "," : "";
  }

  get maskType() {
    if (
      this._type === "text" ||
      this._type === "number" ||
      this._type === "tel" ||
      this._type === "range"
    ) {
      return "text";
    } else if (this._type === "currency") {
      return this._type;
    }
    return "";
  }
  get getIgnoreMask() {
    let index = findIndex(
      this._propertyObj.customProperties,
      x => x.label === "formatter"
    );
    if (index > -1) {
      return false;
    }
    return true;
  }

  preventKeyDown = event => event.stopPropagation();
}
