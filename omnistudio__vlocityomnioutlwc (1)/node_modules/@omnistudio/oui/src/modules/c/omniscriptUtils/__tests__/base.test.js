/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { applyCallRespBase } from '../base.js';
// silence all print statements, COMMENT TO SHOW CONSOLE LOGS
window.console.log = jest.fn(); // this is the silence

const BLOCK = 'Block';
const EDIT_BLOCK = 'Edit Block';
const TEXT = 'text';
const IS_API = true;
const IS_VALIDATION = false;

const TEXT_DATA = ['data1', 'data2', 'data3'];

// Mocks the component passed into applyCallRespBase
function createMockComponent() {
    return {
        scriptHeaderDef: {
            labelMap: {},
            acUiElements: {},
            apiUiElements: {},
            allowOverwrite: true, // true by default
        },
        querySelectorAll: jest.fn(),
    };
}
// Mocks the query response for queryOmniComp
function createMockQueryResponse(options) {
    let count = options?.count || 1;
    let type = options?.type || '';
    let repeat = options?.repeat || true;
    const components = [];
    for (let i = 0; i < count; i++) {
        let comp = {
            querySelectorAll: jest.fn(),
            handleAdd: jest.fn(),
            handleRemove: jest.fn(),
            applyCallResp: jest.fn(),
            jsonDef: {
                propSetMap: {
                    repeat: repeat,
                },
                type: type,
            },
        };
        if (options.type === EDIT_BLOCK) {
            comp.isEmpty = jest.fn(() => options.isEmpty === true);
        }

        components.push(comp);
    }
    return components;
}

describe('applyCallRespBase for Edit Block', () => {
    const COMP = createMockComponent();
    COMP.scriptHeaderDef.labelMap = { EditBlock1: null };
    COMP.scriptHeaderDef.acUiElements = { EditBlock1: null };
    COMP.scriptHeaderDef.apiUiElements = { EditBlock1: null };
    describe('allowOverwrite is true', () => {
        COMP.scriptHeaderDef.allowOverwrite = true;

        // Even when Edit Block has no children, there will always exist an Edit Block component
        // in the DOM, and isEmpty() is set to true in the components queried
        it('should call handleAdd when Edit Block has no children', () => {
            const MOCK_SET_VALUES_EDIT_BLOCK = {
                EditBlock1: [{ Text1: TEXT_DATA[0] }, { Text1: TEXT_DATA[1] }, { Text1: TEXT_DATA[2] }],
            };
            // isEmpty set to true to mock edit block with no children
            const EDIT_BLOCK_QUERY = createMockQueryResponse({ count: 1, type: EDIT_BLOCK, isEmpty: true });

            // mock query for edit block data
            COMP.querySelectorAll.mockReturnValue(EDIT_BLOCK_QUERY);
            applyCallRespBase(MOCK_SET_VALUES_EDIT_BLOCK, COMP, IS_API, IS_VALIDATION);
            expect(EDIT_BLOCK_QUERY[0].handleAdd).toHaveBeenCalledTimes(3);
            expect(EDIT_BLOCK_QUERY[0].handleAdd).toHaveBeenCalledWith('api', MOCK_SET_VALUES_EDIT_BLOCK.EditBlock1[0]);
            expect(EDIT_BLOCK_QUERY[0].handleAdd).toHaveBeenCalledWith('api', MOCK_SET_VALUES_EDIT_BLOCK.EditBlock1[1]);
            expect(EDIT_BLOCK_QUERY[0].handleAdd).toHaveBeenCalledWith('api', MOCK_SET_VALUES_EDIT_BLOCK.EditBlock1[2]);
            expect(EDIT_BLOCK_QUERY[0].applyCallResp).toHaveBeenCalledTimes(1);
        });

        it('should call handleRemove', () => {
            const MOCK_SET_VALUES_EDIT_BLOCK = {
                EditBlock1: [{ Text1: TEXT_DATA[0] }],
            };
            const EDIT_BLOCK_QUERY = createMockQueryResponse({ count: 3, type: EDIT_BLOCK });
            COMP.querySelectorAll.mockReturnValue(EDIT_BLOCK_QUERY);
            applyCallRespBase(MOCK_SET_VALUES_EDIT_BLOCK, COMP, IS_API, IS_VALIDATION);
            expect(EDIT_BLOCK_QUERY[2].handleRemove).toHaveBeenCalledTimes(1);
            expect(EDIT_BLOCK_QUERY[1].handleRemove).toHaveBeenCalledTimes(1);
            expect(EDIT_BLOCK_QUERY[0].handleRemove).toHaveBeenCalledTimes(0);
            expect(EDIT_BLOCK_QUERY[0].applyCallResp).toHaveBeenCalledTimes(1);
        });

        it('should call handleRemove when input data is null', () => {
            // clears all children in edit block
            const MOCK_SET_VALUES_EDIT_BLOCK = {
                EditBlock1: null,
            };
            const EDIT_BLOCK_QUERY = createMockQueryResponse({ count: 3, type: EDIT_BLOCK, repeat: false });
            COMP.querySelectorAll.mockReturnValue(EDIT_BLOCK_QUERY);
            applyCallRespBase(MOCK_SET_VALUES_EDIT_BLOCK, COMP, IS_API, IS_VALIDATION);
            expect(EDIT_BLOCK_QUERY[2].handleRemove).toHaveBeenCalledTimes(0);
            expect(EDIT_BLOCK_QUERY[1].handleRemove).toHaveBeenCalledTimes(0);
            expect(EDIT_BLOCK_QUERY[0].handleRemove).toHaveBeenCalledTimes(0);
            // only the first edit block child is called and internally it tells all of the
            // other children to remove themselves.
            expect(EDIT_BLOCK_QUERY[0].applyCallResp).toHaveBeenCalledWith(null, IS_API, IS_VALIDATION);
        });
        it('should call handleRemove when input data is []', () => {
            // clears all children in edit block
            const MOCK_SET_VALUES_EDIT_BLOCK = {
                EditBlock1: [],
            };
            const EDIT_BLOCK_QUERY = createMockQueryResponse({ count: 3, type: EDIT_BLOCK, repeat: false });
            COMP.querySelectorAll.mockReturnValue(EDIT_BLOCK_QUERY);
            applyCallRespBase(MOCK_SET_VALUES_EDIT_BLOCK, COMP, IS_API, IS_VALIDATION);
            // a different way to clear an edit block by removing all of the children backwards
            expect(EDIT_BLOCK_QUERY[2].handleRemove).toHaveBeenCalledTimes(1);
            expect(EDIT_BLOCK_QUERY[1].handleRemove).toHaveBeenCalledTimes(1);
            expect(EDIT_BLOCK_QUERY[0].handleRemove).toHaveBeenCalledTimes(1);
            expect(EDIT_BLOCK_QUERY[0].applyCallResp).toHaveBeenCalledTimes(0);
        });
    });
});

describe('applyCallRespBase for Block', () => {
    const COMP = createMockComponent();
    COMP.scriptHeaderDef.labelMap = { Block1: null };
    COMP.scriptHeaderDef.acUiElements = { Block1: null };
    COMP.scriptHeaderDef.apiUiElements = { Block1: null };
    it('should call handleAdd when new number of blocks > current number of blocks', () => {
        const MOCK_SET_VALUES_BLOCK = {
            Block1: [{ Text1: TEXT_DATA[0] }, { Text1: TEXT_DATA[1] }, { Text1: TEXT_DATA[2] }],
        };
        const BLOCK_QUERY = createMockQueryResponse({ count: 1, type: BLOCK });

        // mock query for edit block data
        COMP.querySelectorAll.mockReturnValue(BLOCK_QUERY);
        applyCallRespBase(MOCK_SET_VALUES_BLOCK, COMP, IS_API, IS_VALIDATION);
        // Only needs 2 handleAdds called compared to Edit Block's 3 because
        // Block always has at least 1 Block component on the page if visible
        expect(BLOCK_QUERY[0].handleAdd).toHaveBeenCalledTimes(2);
        expect(BLOCK_QUERY[0].applyCallResp).toHaveBeenCalledTimes(1);
    });

    it('should call handleRemove when new number of blocks < current number of blocks', () => {
        const MOCK_SET_VALUES_BLOCK = {
            Block1: [{ Text1: TEXT_DATA[2] }, { Text1: TEXT_DATA[0] }],
        };
        const BLOCK_QUERY = createMockQueryResponse({ count: 3, type: BLOCK });

        // mock query for edit block data
        COMP.querySelectorAll.mockReturnValue(BLOCK_QUERY);
        applyCallRespBase(MOCK_SET_VALUES_BLOCK, COMP, IS_API, IS_VALIDATION);
        // Only needs 2 handleAdds called compared to Edit Block's 3 because
        // Block always has at least 1 Block component on the page if visible
        expect(BLOCK_QUERY[2].handleRemove).toHaveBeenCalledTimes(1);
        expect(BLOCK_QUERY[1].handleRemove).toHaveBeenCalledTimes(0);
        expect(BLOCK_QUERY[0].handleRemove).toHaveBeenCalledTimes(0);
        expect(BLOCK_QUERY[1].applyCallResp).toHaveBeenCalledWith(MOCK_SET_VALUES_BLOCK.Block1[1], IS_API, IS_VALIDATION);
        expect(BLOCK_QUERY[0].applyCallResp).toHaveBeenCalledWith(MOCK_SET_VALUES_BLOCK.Block1[0], IS_API, IS_VALIDATION);
    });
});

describe('applyCallRespBase for input element (Text)', () => {
    const COMP = createMockComponent();
    COMP.scriptHeaderDef.labelMap = { Text1: null };
    COMP.scriptHeaderDef.acUiElements = { Text1: null };
    COMP.scriptHeaderDef.apiUiElements = { Text1: null };
    it('should call applyCallResp', () => {
        const MOCK_SET_VALUES_TEXT = { Text1: TEXT_DATA[0] };
        // repeat added as a property and set to false for elements with repeat disabled
        const TEXT_QUERY = createMockQueryResponse({ count: 1, type: TEXT, repeat: false });
        COMP.querySelectorAll.mockReturnValue(TEXT_QUERY);
        applyCallRespBase(MOCK_SET_VALUES_TEXT, COMP, IS_API, IS_VALIDATION);
        expect(TEXT_QUERY[0].applyCallResp).toHaveBeenCalledTimes(1);
        expect(TEXT_QUERY[0].applyCallResp).toHaveBeenCalledWith(TEXT_DATA[0], IS_API, IS_VALIDATION);
    });

    it('should call applyCallResp when input data is null', () => {
        const MOCK_SET_VALUES_TEXT = { Text1: null };
        const TEXT_QUERY = createMockQueryResponse({ count: 1, type: TEXT });
        COMP.querySelectorAll.mockReturnValue(TEXT_QUERY);
        applyCallRespBase(MOCK_SET_VALUES_TEXT, COMP, IS_API, IS_VALIDATION);
        expect(TEXT_QUERY[0].applyCallResp).toHaveBeenCalledTimes(1);
        expect(TEXT_QUERY[0].applyCallResp).toHaveBeenCalledWith(null, IS_API, IS_VALIDATION);
    });

    it('should call handleAdd', () => {
        const MOCK_SET_VALUES_BLOCK = {
            Text1: TEXT_DATA,
        };
        const TEXT_QUERY = createMockQueryResponse({ count: 1, type: TEXT });

        // mock query for edit block data
        COMP.querySelectorAll.mockReturnValue(TEXT_QUERY);
        applyCallRespBase(MOCK_SET_VALUES_BLOCK, COMP, IS_API, IS_VALIDATION);
        // Only needs 2 handleAdds called compared to Edit Block's 3 because
        // Block always has at least 1 Block component on the page if visible
        expect(TEXT_QUERY[0].handleAdd).toHaveBeenCalledTimes(2);
        expect(TEXT_QUERY[0].applyCallResp).toHaveBeenCalledTimes(1);
    });
});
