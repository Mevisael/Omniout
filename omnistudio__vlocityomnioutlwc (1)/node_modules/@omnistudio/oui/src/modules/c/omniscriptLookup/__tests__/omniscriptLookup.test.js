/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { createElement, api } from 'lwc';
import OmniscriptLookup from 'c/omniscriptLookup';
import { delay } from 'c/asyncUtils';
import { getPicklistValues } from 'lightning/uiObjectInfoApi';
import { registerTestWireAdapter } from '@salesforce/sfdx-lwc-jest';
import { configureRemoteParams } from '../omniscriptLookupUtils';
import * as namespaceHandler from '../../omniscriptInternalUtils/namespaceHandler.js';

jest.mock('c/omniscriptActionUtils', () => ({
    OmniscriptActionCommonUtil: function() {
        return {
            executeAction: () =>
                Promise.resolve({
                    result: {
                        options: [
                            {
                                value: 'a',
                                name: '0014T00000ECyZ3QAL',
                            },
                            {
                                value: 'b',
                                name: '0014T000007vQMyQAM',
                            },
                            {
                                value: 'c',
                                name: '0015T000007vQMyQAX',
                            },
                        ],
                    },
                }),
        };
    },
}));

const mockData = {
    data: {
        controllerValues: {},
        defaultValue: null,
        url: '/services/data/v52.0/ui-api/object-info/Contact/picklist-values/0124T000000U9zKQAS/oui_dailylwc__Type__c',
        values: [
            {
                attributes: null,
                label: 'Licensed Agent',
                validFor: [],
                value: 'Licensed Agent',
            },
            {
                attributes: null,
                label: 'Broker',
                validFor: [],
                value: 'Broker',
            },
            {
                attributes: null,
                label: 'Associate Agent',
                validFor: [],
                value: 'Associate Agent',
            },
            {
                attributes: null,
                label: 'Managing Agent',
                validFor: [],
                value: 'Managing Agent',
            },
        ],
    },
};

const currentPageReferenceAdapter = registerTestWireAdapter(getPicklistValues);

/**
 * Class extending OmniscriptLookup to expose functions for unit test
 */
class testosLookup extends OmniscriptLookup {
    @api testGenerateUniqueAttributes(options) {
        this.generateUniqueAttributes(options);
    }
}

describe('c-omniscript-lookup', () => {
    const mockGetRecord = require('./mocks/getRecord.json');
    const mockScriptHeaderDef = require('./mocks/scriptHeaderDef.json');
    const mockGetRecordForRequired = require('./mocks/getRecordForRequired.json');

    let lookup = null;

    beforeEach(() => {
        lookup = createElement('c-omniscript-lookup', {
            is: OmniscriptLookup,
        });
        lookup.key = mockGetRecord.name;
        lookup.jsonDef = mockGetRecord;
        lookup.dataOmniKey = mockGetRecord.index;
        lookup.jsonData = null;
        lookup.layout = 'lightning';
        lookup.scriptHeaderDef = mockScriptHeaderDef;
    });

    afterEach(() => {
        while (document.body.firstChild) {
            document.body.removeChild(document.body.firstChild);
        }
        lookup = null;
    });

    // eslint-disable-next-line @lwc/lwc/no-async-await
    it('should display number of options correctly after the mock data is emitted', async () => {
        lookup.layout = 'lightning';
        document.body.appendChild(lookup);
        currentPageReferenceAdapter.emit(mockData);

        const input = lookup.shadowRoot.querySelector('input');
        lookup.focus();

        const event = new CustomEvent('keyup');
        event.key = 'ArrowDown';
        input.dispatchEvent(event); // expand menu
        await delay(0);

        const options = lookup.shadowRoot.querySelectorAll('[role="option"]');
        expect(options.length).toBe(5); // includes --
    });

    it('should render in lightning mode', () => {
        let jsonDefCopy = JSON.parse(JSON.stringify(mockGetRecord));
        jsonDefCopy.propSetMap.repeat = true;
        jsonDefCopy.propSetMap.required = true;
        lookup.jsonDef = jsonDefCopy;
        lookup.layout = 'lightning';
        document.body.appendChild(lookup);
        expect(lookup.shadowRoot.children).not.toHaveLength(0);
        expect(lookup.shadowRoot.querySelector('.slds-grid')).toBeTruthy();
    });

    it('should render in newport mode', () => {
        let jsonDefCopy = JSON.parse(JSON.stringify(mockGetRecord));
        jsonDefCopy.propSetMap.repeat = true;
        lookup.jsonDef = jsonDefCopy;
        lookup.layout = 'newport';
        document.body.appendChild(lookup);
        expect(lookup.shadowRoot.children).not.toHaveLength(0);
        expect(lookup.shadowRoot.querySelector('.nds-combobox_container')).toBeTruthy();
    });

    // eslint-disable-next-line @lwc/lwc/no-async-await
    it('should expand if the down arrow key is pressed while focused', async () => {
        document.body.appendChild(lookup);
        const input = lookup.shadowRoot.querySelector('input');
        lookup.focus();

        const event = new CustomEvent('keyup');
        event.key = 'ArrowDown';
        input.dispatchEvent(event); // expand menu
        await delay(0);

        const element = lookup.shadowRoot.querySelector('[aria-expanded]');
        const options = lookup.shadowRoot.querySelectorAll('[role="option"]');
        expect(options.length).toBe(4);
        expect(element.getAttribute('aria-expanded')).toBe('true');
    });
    // lookup accessibility test for error  on required
    it('should announce error on blur', () => {
        lookup.layout = 'lightning';
        lookup.jsonDef = mockGetRecordForRequired;
        document.body.appendChild(lookup);

        const input = lookup.shadowRoot.querySelector('input');

        lookup.lookupDisplay = '';
        return Promise.resolve()
            .then(() => {
                const event = new CustomEvent('blur');
                input.dispatchEvent(event);
            })
            .then(() => {
                const errorElem = lookup.shadowRoot.querySelector('.slds-form-element__help');
                const roleAttr = errorElem ? errorElem.getAttribute('role') : '';
                expect(roleAttr).toBe('alert');
            });
    });

    it('should have  same aria-describedby same as errormessageblock after  blur on required data', () => {
        lookup.layout = 'lightning';
        lookup.jsonDef = mockGetRecordForRequired;
        document.body.appendChild(lookup);

        const input = lookup.shadowRoot.querySelector('input');

        lookup.lookupDisplay = '';
        return Promise.resolve()
            .then(() => {
                const event = new CustomEvent('blur');
                input.dispatchEvent(event);
            })
            .then(() => {
                const comboboxElem = lookup.shadowRoot.querySelector('.slds-input');
                const describedby = comboboxElem ? comboboxElem.getAttribute('aria-describedby') : '';
                const errorElem = lookup.shadowRoot.querySelector('.slds-form-element__help');
                const idAttr = errorElem ? errorElem.getAttribute('id') : '';
                expect(describedby).toBe(idAttr);
            });
    });

    // eslint-disable-next-line @lwc/lwc/no-async-await
    it('should set aria-activedescendant to the id of the highlighted option', async () => {
        document.body.appendChild(lookup);
        const input = lookup.shadowRoot.querySelector('input');
        lookup.focus();

        const event = new CustomEvent('keyup');
        event.key = 'ArrowDown';
        input.dispatchEvent(event); // expand menu
        await delay(0);

        input.dispatchEvent(event); // go to --
        input.dispatchEvent(event); // go to first option
        await delay(0);

        expect(input.getAttribute('aria-activedescendant')).toEqual(expect.stringContaining('option-1'));
    });

    // eslint-disable-next-line @lwc/lwc/no-async-await
    it('should collapse on blur', async () => {
        document.body.appendChild(lookup);
        const input = lookup.shadowRoot.querySelector('input');
        lookup.focus();

        const event = new CustomEvent('keyup');
        event.key = 'ArrowDown';
        input.dispatchEvent(event); // expand menu
        await delay(0);

        input.dispatchEvent(event); // go to --
        input.dispatchEvent(event); // go to first option
        input.dispatchEvent(new CustomEvent('blur'));
        await delay(0);

        const element = lookup.shadowRoot.querySelector('[aria-expanded]');
        expect(element.getAttribute('aria-expanded')).toBe('false');
        expect(input.getAttribute('aria-activedescendant')).toEqual(null);
    });

    it('should clear custom validity on focusout', () => {
        document.body.appendChild(lookup);

        lookup.applyCallResp('custom error', false, true);
        expect(lookup.reportValidity()).toBe(false);

        lookup.focus();
        expect(lookup.reportValidity()).toBe(false);

        const input = lookup.shadowRoot.querySelector('input');
        input.dispatchEvent(new CustomEvent('focusout', { bubbles: true }));
        expect(lookup.reportValidity()).toBe(true);
    });

    // eslint-disable-next-line @lwc/lwc/no-async-await
    it('should set value after clearing custom validity', async () => {
        document.body.appendChild(lookup);
        lookup.applyCallResp('custom error', false, true);
        lookup.focus();

        const input = lookup.shadowRoot.querySelector('input');
        lookup.focus();

        const arrowDown = new CustomEvent('keyup');
        arrowDown.key = 'ArrowDown';
        const arrowUp = new CustomEvent('keyup');
        arrowUp.key = 'ArrowUp';
        const escape = new CustomEvent('keyup');
        escape.key = 'Escape';

        input.dispatchEvent(arrowDown); // expand menu
        await delay(0);

        input.dispatchEvent(arrowDown); // go to --
        input.dispatchEvent(arrowDown); // go to first option
        await delay(0);

        input.dispatchEvent(arrowUp); // go to --
        input.dispatchEvent(escape); // close
        await delay(0);

        const element = lookup.shadowRoot.querySelector('[aria-expanded]');
        expect(element.getAttribute('aria-expanded')).toBe('false');

        input.dispatchEvent(arrowDown); // expand menu
        await delay(0);

        input.dispatchEvent(arrowDown); // go to --
        input.dispatchEvent(arrowDown); // go to first option
        await delay(0);

        // select first option
        const enter = new CustomEvent('keyup');
        enter.key = 'Enter';
        input.dispatchEvent(enter);
        await delay(0);

        input.dispatchEvent(new CustomEvent('focusout', { bubbles: true }));
        expect(input.reportValidity()).toBe(true);
        input.isFocusEventAttached = false;
    });

    it('should emit omnirepeat in Lightning mode when repeat button is clicked', () => {
        lookup.layout = 'lightning';
        let jsonDefCopy = JSON.parse(JSON.stringify(mockGetRecord));
        jsonDefCopy.propSetMap.repeat = true;
        lookup.jsonDef = jsonDefCopy;
        document.body.appendChild(lookup);
        const addButton = lookup.shadowRoot.querySelector('.omni-repeat-button-group > button');
        return new Promise(resolve => {
            lookup.addEventListener('omnirepeat', () => resolve());
            addButton.click();
        });
    });

    it('should emit omnirepeat in Newport mode when repeat button is clicked', () => {
        lookup.layout = 'newport';
        let jsonDefCopy = JSON.parse(JSON.stringify(mockGetRecord));
        jsonDefCopy.propSetMap.repeat = true;
        lookup.jsonDef = jsonDefCopy;
        document.body.appendChild(lookup);
        const addButton = lookup.shadowRoot.querySelector('.omni-repeat-button-group > button');
        return new Promise(resolve => {
            lookup.addEventListener('omnirepeat', () => resolve());
            addButton.click();
        });
    });

    describe('configureRemoteParams', () => {
        const CUSTOM = 'Custom';
        const CLASS_NAME = 'some_class_name';
        const METHOD_NAME = 'some_method_name';
        const PICKLIST_FILTER = 'PicklistFilteredbyRecordType';
        const PICKLIST_OBJECT = 'OmniProcess';
        const PICKLIST_FIELD = 'Type';
        const PICKLIST_RECORD_TYPE = 'RecordType1';
        const NAMESPACE_WITH_DOT = 'omnistudio.';
        const getNamespaceDotNotation = jest.spyOn(namespaceHandler, 'getNamespaceDotNotation');
        getNamespaceDotNotation.mockImplementation(() => NAMESPACE_WITH_DOT);
        const COMP = {
            jsonDef: { propSetMap: { dataSource: {} } },
            jsonData: {},
            scriptHeaderDef: {
                labelMap: {},
            },
        };
        it('should return a result for type = Custom ', () => {
            COMP.jsonDef.propSetMap.dataSource.type = CUSTOM;
            COMP.jsonDef.propSetMap.dataSource.source = `${CLASS_NAME}.${METHOD_NAME}`;
            const actualResult = configureRemoteParams(COMP);
            expect(actualResult.sClassName).toEqual(CLASS_NAME);
            expect(actualResult.sMethodName).toEqual(METHOD_NAME);
        });
        it('should return a result for type = PicklistFilteredbyRecordType ', () => {
            COMP.jsonDef.propSetMap.dataSource.type = PICKLIST_FILTER;
            COMP.jsonDef.propSetMap.dataSource.picklistObjectAndField = `${PICKLIST_OBJECT}.${PICKLIST_FIELD}`;
            COMP.jsonDef.propSetMap.dataSource.picklistRecordType = PICKLIST_RECORD_TYPE;
            const OPTION = {
                picklistObject: PICKLIST_OBJECT,
                picklistField: PICKLIST_FIELD,
                picklistRecordType: PICKLIST_RECORD_TYPE,
            };
            const actualResult = configureRemoteParams(COMP);
            expect(actualResult.sClassName).toEqual(`${NAMESPACE_WITH_DOT}DefaultOmniScriptSObjectPicklist`);
            expect(actualResult.sMethodName).toEqual('GetSObjectPicklistValues');
            expect(actualResult.options).toEqual(JSON.stringify(OPTION));
        });
    });

    describe('prefilling', () => {
        const LOOKUP_DISPLAY_VALUE = 'lookup display value';
        const LOOKUP_JSON_PATH = 'Step1:Lookup1';
        const LOOKUP_JSON_VALUE = 'lookup json value';

        // eslint-disable-next-line @lwc/lwc/no-async-await
        it('should prefill with object', async () => {
            document.body.appendChild(lookup);
            lookup.applyCallResp(
                {
                    value: LOOKUP_DISPLAY_VALUE,
                    name: LOOKUP_JSON_VALUE,
                },
                true,
                false,
            );
            await delay(0);
            expect(lookup.reportValidity()).toBe(true);

            const inputObject = lookup.shadowRoot.querySelector('input');
            expect(inputObject.value).toBe(LOOKUP_DISPLAY_VALUE);
        });

        // eslint-disable-next-line @lwc/lwc/no-async-await
        it('should prefill with string value and no options', async () => {
            document.body.appendChild(lookup);
            lookup.applyCallResp(LOOKUP_JSON_VALUE, true, false);
            await delay(0);
            expect(lookup.reportValidity()).toBe(true);

            const inputString = lookup.shadowRoot.querySelector('input');
            expect(inputString.value).toBe(LOOKUP_JSON_VALUE);
        });

        // eslint-disable-next-line @lwc/lwc/no-async-await
        it('should prefill with string and resuming save for later', async () => {
            // mock json data and mock the formatted data
            lookup.jsonData = {
                OmniScriptFmtData: {
                    [LOOKUP_JSON_PATH]: LOOKUP_DISPLAY_VALUE,
                },
            };
            document.body.appendChild(lookup);

            // trigger prefill
            lookup.applyCallResp(LOOKUP_JSON_VALUE, true, false);
            await delay(0);

            const inputObject = lookup.shadowRoot.querySelector('input');
            expect(inputObject.value).toBe(LOOKUP_DISPLAY_VALUE);
        });

        // eslint-disable-next-line @lwc/lwc/no-async-await
        it('should prefill with value and name from saved options', async () => {
            let jsonDefCopy = JSON.parse(JSON.stringify(mockGetRecord));
            jsonDefCopy.options = [
                {
                    value: LOOKUP_DISPLAY_VALUE,
                    name: LOOKUP_JSON_VALUE,
                },
            ];
            lookup.layout = 'lightning';
            lookup.jsonDef = jsonDefCopy;
            document.body.appendChild(lookup);

            // trigger prefill
            lookup.applyCallResp(LOOKUP_JSON_VALUE, true, false);
            await delay(0);

            const inputObject = lookup.shadowRoot.querySelector('input');
            expect(inputObject.value).toBe(LOOKUP_DISPLAY_VALUE);
        });
    });

    describe('generateUniqueAttributes', () => {
        const LOOKUP_DISPLAY_VALUE = 'lookup display value';
        const LOOKUP_JSON_VALUE = 'lookup display value';
        let testlookup;

        beforeEach(() => {
            testlookup = createElement('test-omniscript-lookup', {
                is: testosLookup,
            });
            testlookup.key = mockGetRecord.name;
            testlookup.jsonDef = mockGetRecord;
            testlookup.dataOmniKey = mockGetRecord.index;
            testlookup.jsonData = null;
            testlookup.layout = 'lightning';
            testlookup.scriptHeaderDef = mockScriptHeaderDef;
        });

        afterEach(() => {
            while (document.body.firstChild) {
                document.body.removeChild(document.body.firstChild);
            }
            testlookup = null;
        });

        it('should add unique key and id to options array', () => {
            document.body.appendChild(testlookup);
            const options = [
                {
                    value: LOOKUP_DISPLAY_VALUE,
                    name: LOOKUP_JSON_VALUE,
                },
            ];
            testlookup.testGenerateUniqueAttributes(options);
            const result = [
                {
                    key: 0,
                    id: 'option-0',
                    value: LOOKUP_DISPLAY_VALUE,
                    name: LOOKUP_JSON_VALUE,
                },
            ];
            expect(options).toEqual(result);
        });

        it('should set id equal to key if key exists in options array', () => {
            const LOOKUP_KEY = 'lookupkey';
            document.body.appendChild(testlookup);
            const options = [
                {
                    key: LOOKUP_KEY,
                    value: LOOKUP_DISPLAY_VALUE,
                    name: LOOKUP_JSON_VALUE,
                },
            ];
            testlookup.testGenerateUniqueAttributes(options);
            const result = [
                {
                    key: LOOKUP_KEY,
                    id: LOOKUP_KEY,
                    value: LOOKUP_DISPLAY_VALUE,
                    name: LOOKUP_JSON_VALUE,
                },
            ];
            expect(options).toEqual(result);
        });
    });
});
