/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { createElement } from "lwc";
import { delay } from "c/asyncUtils";
import VlocityDatePicker from "c/datePicker";
jest.mock(
  "@salesforce/label/c.cmpDayJsLocaleFormats",
  () => {
    return {
      default:
        '{"name":"en","weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"months":["January","February","March","April","May","June","July","August","September","October","November","December"]}'
    };
  },
  { virtual: true }
);

jest.mock(
  "@salesforce/label/c.cmpLocaleFormatsInvalid",
  () => {
    return {
      default:
        'Unable to render due to invalid localeFormat. Please provide a valid localeFormat in the form of {"name":"en","weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"months":["January","February","March","April","May","June","July","August","September","October","November","December"]}'
    };
  },
  { virtual: true }
);
jest.mock(
  "@salesforce/label/c.cmpRangeUnderflow",
  () => {
    return { default: "Date is before allowed range." };
  },
  { virtual: true }
);
jest.mock(
  "@salesforce/label/c.cmpRangeOverflow",
  () => {
    return { default: "Date is after allowed range." };
  },
  { virtual: true }
);
jest.mock(
  "@salesforce/label/c.cmpFieldValueMissing",
  () => {
    return { default: "Complete this field." };
  },
  { virtual: true }
);

const DEBOUNCE = 10;

const arrowLeft = new CustomEvent("keydown");
arrowLeft.key = "ArrowLeft";

const arrowRight = new CustomEvent("keydown");
arrowRight.key = "ArrowRight";

const arrowDown = new CustomEvent("keydown");
arrowDown.key = "ArrowDown";

const arrowUp = new CustomEvent("keydown");
arrowUp.key = "ArrowUp";

const pageUp = new CustomEvent("keydown");
pageUp.key = "PageUp";

const pageDown = new CustomEvent("keydown");
pageDown.key = "PageDown";

const altPageUp = new CustomEvent("keydown");
altPageUp.key = "PageUp";
altPageUp.altKey = true;

const altPageDown = new CustomEvent("keydown");
altPageDown.key = "PageDown";
altPageDown.altKey = true;

const home = new CustomEvent("keydown");
home.key = "Home";

const end = new CustomEvent("keydown");
end.key = "End";

const escape = new CustomEvent("keypress");
escape.key = "Escape";

const tab = new CustomEvent("keydown");
tab.key = "Tab";

describe("c-date-picker", () => {
  let element = null;
  let date = new Date(2019, 11, 13);
  let dateVal = date.toISOString();

  beforeEach(() => {
    element = createElement("c-date-picker", {
      is: VlocityDatePicker
    });
    element.placeholder = "Select Date";
    element.theme = "slds";
    element.name = "Date Picker";
    element.label = "Date";
  });

  afterEach(() => {
    while (document.body.firstChild) {
      document.body.removeChild(document.body.firstChild);
    }
    element = null;
  });

  it("renders DOM elements", () => {
    document.body.appendChild(element);
    expect(element.shadowRoot.children).not.toHaveLength(0);
  });

  /**
   * Check if the theme is applied properly
   */
  it("Check if theme is set", () => {
    document.body.appendChild(element);
    const button = element.shadowRoot.querySelector("div");
    let index = button.className.indexOf("slds") !== -1 ? true : false;
    expect(index).toBe(true);
  });

  /* Check if the variant disabled */
  it("Check If label is set", () => {
    document.body.appendChild(element);
    const label = element.shadowRoot.querySelector("label");
    expect(label.textContent).toBe("Date");
  });

  /* Check if the required value is checked */
  it("Check If required value is checked", () => {
    element.required = true;
    document.body.appendChild(element);
    expect(element.checkValidity()).toBe(false);
  });

  /* Check if the reportValidity works */
  it("Check If reportValidity works", () => {
    element.required = true;
    document.body.appendChild(element);
    expect(element.reportValidity()).toBe(false);
  });

  /* Check if the setCustomValidity works */
  it("Check If setCustomValidity works", () => {
    document.body.appendChild(element);
    element.setCustomValidity("Test error message");
    element.showHelpMessageIfInvalid();
    return Promise.resolve().then(() => {
      return new Promise(function(resolve) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(() => {
          const error = element.shadowRoot.querySelectorAll(
            ".slds-has-error"
          )[1];
          expect(error.textContent).toBe("Test error message");
          resolve();
        }, 10);
      });
    });
  });

  /* Check if the showHelpMessageIfInvalid works */
  it("Check If showHelpMessageIfInvalid works", () => {
    element.required = true;
    document.body.appendChild(element);
    element.showHelpMessageIfInvalid();
    return Promise.resolve().then(() => {
      const error = element.shadowRoot.querySelectorAll(".slds-has-error")[1];
      expect(error.textContent).toBe("Complete this field.");
    });
  });

  /* Check if the focus works */
  it("Check If focus works", () => {
    document.body.appendChild(element);
    element.focus();
    return Promise.resolve().then(() => {
      expect(document.activeElement.nodeName).toBe("C-DATE-PICKER");
    });
  });

  /* Check if the input is set */
  it("Check If input is set", () => {
    element.value = dateVal;
    document.body.appendChild(element);
    return Promise.resolve().then(() => {
      const input = element.shadowRoot.querySelector("input");
      return new Promise(function(resolve) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(() => {
          expect(input.value).toBe("12/13/2019");
          resolve();
        }, 10);
      });
    });
  });

  /* Check if the min date validation is set*/
  it("Check If min date validation is set", () => {
    jest.useRealTimers();
    element.value = dateVal;
    element.min = "2020-04-14T00:00:00.000Z";
    element.format = "MM/DD/YYYY";
    document.body.appendChild(element);
    return new Promise(function(resolve) {
      // eslint-disable-next-line @lwc/lwc/no-async-operation
      setTimeout(() => {
        var input = element.shadowRoot.querySelector("input");
        input.value = dateVal;
        element.showHelpMessageIfInvalid();
        resolve();
      }, 1000);
    }).then(function() {
      return new Promise(function(resolve) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(() => {
          const error = element.shadowRoot.querySelectorAll(
            ".slds-has-error"
          )[1];
          expect(error.textContent).toBe("Date is before allowed range.");
          resolve();
        }, 1000);
      });
    });
  });

  /* Check if the max date validation is set*/
  it("Check If max date validation is set", () => {
    jest.useRealTimers();
    element.value = dateVal;
    element.max = "2019-05-14T00:00:00.000Z";
    element.format = "MM/DD/YYYY";
    document.body.appendChild(element);
    return new Promise(function(resolve) {
      // eslint-disable-next-line @lwc/lwc/no-async-operation
      setTimeout(() => {
        var input = element.shadowRoot.querySelector("input");
        input.value = dateVal;
        element.showHelpMessageIfInvalid();
        resolve();
      }, 1000);
    }).then(function() {
      return new Promise(function(resolve) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(() => {
          const error = element.shadowRoot.querySelectorAll(
            ".slds-has-error"
          )[1];
          expect(error.textContent).toBe("Date is after allowed range.");
          resolve();
        }, 1000);
      });
    });
  });

  /* Check if the output format is set */
  it("Check If output format is set", () => {
    let output =
      date.getMonth() + 1 + "/" + date.getDate() + "/" + date.getFullYear();
    element.value = dateVal;
    element.outputFormat = "MM/DD/YYYY";
    document.body.appendChild(element);
    return Promise.resolve().then(() => {
      return new Promise(function(resolve) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(() => {
          expect(element.value).toBe(output);
          resolve();
        }, 10);
      });
    });
  });

  /* Check if the output type is set */
  it("Check If output type is set", () => {
    element.value = dateVal;
    element.outputType = "date";
    document.body.appendChild(element);
    return Promise.resolve().then(() => {
      return new Promise(function(resolve) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(() => {
          expect(typeof element.value).toBe("object");
          expect(element.value.toString()).toBe(date.toString());
          resolve();
        }, 10);
      });
    });
  });

  /* Check if the format is set */
  it("Check If format is set", () => {
    element.value = dateVal;
    element.format = "MM/DD/YYYY";
    document.body.appendChild(element);
    return Promise.resolve().then(() => {
      const input = element.shadowRoot.querySelector("input");
      return new Promise(function(resolve) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(() => {
          expect(input.value).toBe("12/13/2019");
          resolve();
        }, 10);
      });
    });
  });

  /* Check if the value updates*/
  it("Check If value updates", () => {
    element.value = dateVal;
    element.format = "MM/DD/YYYY";
    document.body.appendChild(element);
    return Promise.resolve().then(() => {
      return new Promise(function(resolve) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(() => {
          const input = element.shadowRoot.querySelector("input");
          input.value = dateVal;
          input.dispatchEvent(new Event("mousedown"));
          resolve();
        }, 10);
      }).then(() => {
        return new Promise(function(resolve) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          setTimeout(() => {
            expect(element.value).toBe("12/13/2019");
            resolve();
          }, 10);
        });
      });
    });
  });

  /* Check if the calendar displays*/
  it("Check If calendar displays", () => {
    element.value = dateVal;
    element.format = "MM/DD/YYYY";
    document.body.appendChild(element);
    return Promise.resolve().then(() => {
      return new Promise(function(resolve) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(() => {
          const input = element.shadowRoot.querySelector("input");
          input.dispatchEvent(new Event("mousedown"));
          resolve();
        }, 10);
      }).then(() => {
        return new Promise(function(resolve) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          setTimeout(() => {
            const year = element.shadowRoot.querySelectorAll("select")[0];
            const month = element.shadowRoot.querySelector("h2");
            const day = element.getElementsByClassName("dayId13")[0];
            expect(month.textContent).toBe("December");
            expect(year.value).toBe("2019");
            let activeClass =
              day.className.indexOf("slds-is-selected") !== -1 ? true : false;
            expect(activeClass).toBe(true);
            resolve();
          }, 100);
        });
      });
    });
  });

  /* Check if the min and max date is set*/
  it("Check If min and max date is set", () => {
    element.value = "2019-04-16T00:00:00.000Z";
    element.min = "2019-04-13T00:00:00.000Z";
    element.max = "2019-05-13T00:00:00.000Z";
    element.format = "MM/DD/YYYY";
    document.body.appendChild(element);
    return Promise.resolve().then(() => {
      return new Promise(function(resolve) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(() => {
          const input = element.shadowRoot.querySelector("input");
          input.dispatchEvent(new Event("mousedown"));
          resolve();
        }, 10);
      }).then(() => {
        return new Promise(function(resolve) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          setTimeout(() => {
            const day = element.getElementsByClassName("dayId8")[0];
            let disabledClass =
              day.className.indexOf("slds-disabled-text") !== -1 ? true : false;
            expect(disabledClass).toBe(true);
            resolve();
          }, 100);
        });
      });
    });
  });

  it("should focus today if no date is set", async () => {
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");
    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    const today = element.shadowRoot.querySelector(".slds-is-today");
    expect(today).toBe(element.shadowRoot.activeElement);

    const ariaCurrent = today.getAttribute("aria-current");
    expect(ariaCurrent).toBe("date");
  });

  it("should hide the calendar when the escape key is pressed", async () => {
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    let isOpen = element.shadowRoot.querySelector(".slds-is-open");
    expect(isOpen).toBeTruthy();

    input.dispatchEvent(escape);
    await delay(DEBOUNCE);

    isOpen = element.shadowRoot.querySelector(".slds-is-open");
    expect(isOpen).toBeFalsy();
  });

  it("should focus the day that has been set", async () => {
    element.value = dateVal;
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");
    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    const day = element.shadowRoot.activeElement.textContent;
    const month = element.shadowRoot.querySelector(
      'h2[data-id="selected_month"]'
    ).textContent;
    const year = element.shadowRoot.querySelector("select").value;

    expect(day).toBe("13");
    expect(month).toBe("December");
    expect(year).toBe("2019");

    const selected = element.shadowRoot.querySelector(".slds-is-selected");
    expect(selected).toBe(element.shadowRoot.activeElement);

    const ariaSelected = selected.getAttribute("aria-selected");
    expect(ariaSelected).toBe("true");
  });

  it("should go to the previous day when the left arrow key is pressed", async () => {
    element.value = dateVal;
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    element.shadowRoot.activeElement.dispatchEvent(arrowLeft);
    await delay(DEBOUNCE);

    const day = element.shadowRoot.activeElement.textContent;
    const month = element.shadowRoot.querySelector(
      'h2[data-id="selected_month"]'
    ).textContent;
    const year = element.shadowRoot.querySelector("select").value;

    expect(day).toBe("12");
    expect(month).toBe("December");
    expect(year).toBe("2019");
  });

  it("can go to the previous month using the left arrow key", async () => {
    element.value = new Date(2019, 11, 1).toISOString();
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    element.shadowRoot.activeElement.dispatchEvent(arrowLeft);
    await delay(DEBOUNCE);

    const day = element.shadowRoot.activeElement.textContent;
    const month = element.shadowRoot.querySelector(
      'h2[data-id="selected_month"]'
    ).textContent;
    const year = element.shadowRoot.querySelector("select").value;

    expect(day).toBe("30");
    expect(month).toBe("November");
    expect(year).toBe("2019");
  });

  it("should go to the next day when the right arrow key is pressed", async () => {
    element.value = dateVal;
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    element.shadowRoot.activeElement.dispatchEvent(arrowRight);
    await delay(DEBOUNCE);

    const day = element.shadowRoot.activeElement.textContent;
    const month = element.shadowRoot.querySelector(
      'h2[data-id="selected_month"]'
    ).textContent;
    const year = element.shadowRoot.querySelector("select").value;

    expect(day).toBe("14");
    expect(month).toBe("December");
    expect(year).toBe("2019");
  });

  it("can go to the next month using the right arrow key", async () => {
    element.value = new Date(2019, 11, 31).toISOString();
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    element.shadowRoot.activeElement.dispatchEvent(arrowRight);
    await delay(DEBOUNCE);

    const day = element.shadowRoot.activeElement.textContent;
    const month = element.shadowRoot.querySelector(
      'h2[data-id="selected_month"]'
    ).textContent;
    const year = element.shadowRoot.querySelector("select").value;

    expect(day).toBe("1");
    expect(month).toBe("January");
    expect(year).toBe("2020");
  });

  it("should go to the previous week when the up arrow key is pressed", async () => {
    element.value = dateVal;
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    element.shadowRoot.activeElement.dispatchEvent(arrowUp);
    await delay(DEBOUNCE);

    const day = element.shadowRoot.activeElement.textContent;
    const month = element.shadowRoot.querySelector(
      'h2[data-id="selected_month"]'
    ).textContent;
    const year = element.shadowRoot.querySelector("select").value;

    expect(day).toBe("6");
    expect(month).toBe("December");
    expect(year).toBe("2019");
  });

  it("can go to the previous month using the up arrow key", async () => {
    element.value = new Date(2019, 11, 1).toISOString();
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    element.shadowRoot.activeElement.dispatchEvent(arrowUp);
    await delay(DEBOUNCE);

    const day = element.shadowRoot.activeElement.textContent;
    const month = element.shadowRoot.querySelector(
      'h2[data-id="selected_month"]'
    ).textContent;
    const year = element.shadowRoot.querySelector("select").value;

    expect(day).toBe("24");
    expect(month).toBe("November");
    expect(year).toBe("2019");
  });

  it("should go to the next week when the down arrow key is pressed", async () => {
    element.value = dateVal;
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    element.shadowRoot.activeElement.dispatchEvent(arrowDown);
    await delay(DEBOUNCE);

    const day = element.shadowRoot.activeElement.textContent;
    const month = element.shadowRoot.querySelector(
      'h2[data-id="selected_month"]'
    ).textContent;
    const year = element.shadowRoot.querySelector("select").value;

    expect(day).toBe("20");
    expect(month).toBe("December");
    expect(year).toBe("2019");
  });

  it("can go to the next month using the down arrow key", async () => {
    element.value = new Date(2019, 11, 31).toISOString();
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    element.shadowRoot.activeElement.dispatchEvent(arrowDown);
    await delay(DEBOUNCE);

    const day = element.shadowRoot.activeElement.textContent;
    const month = element.shadowRoot.querySelector(
      'h2[data-id="selected_month"]'
    ).textContent;
    const year = element.shadowRoot.querySelector("select").value;

    expect(day).toBe("7");
    expect(month).toBe("January");
    expect(year).toBe("2020");
  });

  it("should go to the beginning of the week in the current month when the home key is pressed", async () => {
    element.value = new Date(2019, 11, 30).toISOString();
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    element.shadowRoot.activeElement.dispatchEvent(home);
    await delay(DEBOUNCE);

    const day = element.shadowRoot.activeElement.textContent;
    const month = element.shadowRoot.querySelector(
      'h2[data-id="selected_month"]'
    ).textContent;
    const year = element.shadowRoot.querySelector("select").value;

    expect(day).toBe("29");
    expect(month).toBe("December");
    expect(year).toBe("2019");
  });

  it("should go to the end of the week in the current month when the end key is pressed", async () => {
    element.value = new Date(2019, 11, 30).toISOString();
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    element.shadowRoot.activeElement.dispatchEvent(end);
    await delay(DEBOUNCE);

    const day = element.shadowRoot.activeElement.textContent;
    const month = element.shadowRoot.querySelector(
      'h2[data-id="selected_month"]'
    ).textContent;
    const year = element.shadowRoot.querySelector("select").value;

    expect(day).toBe("31");
    expect(month).toBe("December");
    expect(year).toBe("2019");
  });

  it("should go to the previous month when the page up key is pressed", async () => {
    element.value = dateVal;
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    element.shadowRoot.activeElement.dispatchEvent(pageUp);
    await delay(DEBOUNCE);

    const day = element.shadowRoot.activeElement.textContent;
    const month = element.shadowRoot.querySelector(
      'h2[data-id="selected_month"]'
    ).textContent;
    const year = element.shadowRoot.querySelector("select").value;

    expect(day).toBe("13");
    expect(month).toBe("November");
    expect(year).toBe("2019");
  });

  it("should go to the next month when the page down key is pressed", async () => {
    element.value = dateVal;
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    element.shadowRoot.activeElement.dispatchEvent(pageDown);
    await delay(DEBOUNCE);

    const day = element.shadowRoot.activeElement.textContent;
    const month = element.shadowRoot.querySelector(
      'h2[data-id="selected_month"]'
    ).textContent;
    const year = element.shadowRoot.querySelector("select").value;

    expect(day).toBe("13");
    expect(month).toBe("January");
    expect(year).toBe("2020");
  });

  it("should go to the previous year when alt + page up is pressed", async () => {
    element.value = dateVal;
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    element.shadowRoot.activeElement.dispatchEvent(altPageUp);
    await delay(DEBOUNCE);

    const day = element.shadowRoot.activeElement.textContent;
    const month = element.shadowRoot.querySelector(
      'h2[data-id="selected_month"]'
    ).textContent;
    const year = element.shadowRoot.querySelector("select").value;

    expect(day).toBe("13");
    expect(month).toBe("December");
    expect(year).toBe("2018");
  });

  it("should go to the next year when alt + page down is pressed", async () => {
    element.value = dateVal;
    document.body.appendChild(element);
    await delay(DEBOUNCE);

    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const select = element.shadowRoot.querySelector("select");
    select.dispatchEvent(tab);

    element.shadowRoot.activeElement.dispatchEvent(altPageDown);
    await delay(DEBOUNCE);

    const day = element.shadowRoot.activeElement.textContent;
    const month = element.shadowRoot.querySelector(
      'h2[data-id="selected_month"]'
    ).textContent;
    const year = element.shadowRoot.querySelector("select").value;

    expect(day).toBe("13");
    expect(month).toBe("December");
    expect(year).toBe("2020");
  });

  it("Should show the previous year in dropdown", async () => {
    // January 7 will be used as a control date. January 7, 2017 should be visible from the previous year's
    // December month. As a result, the previous year (2016) should be viewable from the dropdown.
    element.min = "2017-01-07T00:00:00.000Z";
    document.body.appendChild(element);
    await delay(DEBOUNCE);
    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const dropdownComp = element.shadowRoot.querySelector("select");

    // Expect the dropdown's first element to show 2016 which is the minDate's previous year
    expect(dropdownComp[0].textContent).toBe("2016");
  });

  it("Should not show the previous year in dropdown", async () => {
    // January 7 will be used as a control date. January 7, 2018 should not be visible from the previous
    // year's December month. As a result, the previous year (2017) should NOT be viewable from the dropdown.
    element.min = "2018-01-07T00:00:00.000Z";
    document.body.appendChild(element);
    await delay(DEBOUNCE);
    const input = element.shadowRoot.querySelector("input");

    input.dispatchEvent(new Event("mousedown"));
    await delay(DEBOUNCE);

    const dropdownComp = element.shadowRoot.querySelector("select");

    // Expect the dropdown's first element to show 2018 which is the minDate's current year
    expect(dropdownComp[0].textContent).toBe("2018");
  });

  it("ariaLabel with * testing if required", () => {
    element.ariaLabel = "Date/Time1";
    element.required = true;
    document.body.appendChild(element);

    return Promise.resolve().then(function() {
      expect(element.shadowRoot.querySelector("input").ariaLabel).toBe(
        "*Date/Time1"
      );
    });
  });

  it("ariaLabel without * testing if not required", () => {
    element.ariaLabel = "Date/Time2";
    element.required = false;
    document.body.appendChild(element);

    return Promise.resolve().then(function() {
      expect(element.shadowRoot.querySelector("input").ariaLabel).toBe(
        "Date/Time2"
      );
    });
  });

  it("Check if role alert present on errormessageblock in slds theme", async () => {
    document.body.appendChild(element);

    element.setCustomValidity("Error Message");
    expect(element.reportValidity()).toBe(false);
    return Promise.resolve().then(() => {
      const errorMessageBlock = element.shadowRoot.querySelector(
        ".slds-form-element__help"
      );
      expect(errorMessageBlock).not.toBeNull();
      expect(errorMessageBlock.role).toBe("alert");
    });
  });

  it("Check if role alert present on errormessageblock in newport theme", async () => {
    element.theme = "nds";
    document.body.appendChild(element);

    element.setCustomValidity("Error Message");
    expect(element.reportValidity()).toBe(false);
    return Promise.resolve().then(() => {
      const errorMessageBlock = element.shadowRoot.querySelector(
        ".nds-form-element__help"
      );
      expect(errorMessageBlock).not.toBeNull();
      expect(errorMessageBlock.role).toBe("alert");
    });
  });

  it("test aria-labels are proper for previous secondary dates and current date", async () => {
    element.value = new Date(2021, 12, 25).toISOString();
    document.body.appendChild(element);

    return Promise.resolve().then(async () => {
      const input = element.shadowRoot.querySelector("input");
      input.dispatchEvent(new Event("mousedown"));

      return new Promise(resolve => {
        delay(DEBOUNCE).then(() => {
          const tableDataElements = element.shadowRoot.querySelectorAll("td");

          expect(tableDataElements).toHaveLength(42);
          expect(
            tableDataElements[0]
              .querySelector("span")
              .getAttribute("aria-label")
          ).toBe("Sun Dec 26 2021");
          expect(
            tableDataElements[5]
              .querySelector("span")
              .getAttribute("aria-label")
          ).toBe("Fri Dec 31 2021");
          expect(
            tableDataElements[6]
              .querySelector("span")
              .getAttribute("aria-label")
          ).toBe("Sat Jan 01 2022");
          resolve();
        });
      });
    });
  });

  it("test aria-labels are proper for next secondary dates and current date", async () => {
    element.value = new Date(2021, 11, 25).toISOString();
    document.body.appendChild(element);

    return Promise.resolve().then(async () => {
      const input = element.shadowRoot.querySelector("input");
      input.dispatchEvent(new Event("mousedown"));

      return new Promise(resolve => {
        delay(DEBOUNCE).then(() => {
          const tableDataElements = element.shadowRoot.querySelectorAll("td");

          expect(tableDataElements).toHaveLength(42);
          expect(
            tableDataElements[33]
              .querySelector("span")
              .getAttribute("aria-label")
          ).toBe("Fri Dec 31 2021");
          expect(
            tableDataElements[34]
              .querySelector("span")
              .getAttribute("aria-label")
          ).toBe("Sat Jan 01 2022");
          expect(
            tableDataElements[41]
              .querySelector("span")
              .getAttribute("aria-label")
          ).toBe("Sat Jan 08 2022");
          resolve();
        });
      });
    });
  });

  it("test aria-disabled is set on dates which are out of range specified in min and max properties", () => {
    element.value = "2019-04-16T00:00:00.000Z";
    element.min = "2019-04-13T00:00:00.000Z";
    element.max = "2019-05-13T00:00:00.000Z";
    element.format = "MM/DD/YYYY";
    document.body.appendChild(element);
    return Promise.resolve().then(() => {
      return new Promise(function(resolve) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(() => {
          const input = element.shadowRoot.querySelector("input");
          input.dispatchEvent(new Event("mousedown"));
          resolve();
        }, 10);
      }).then(() => {
        return new Promise(function(resolve) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          setTimeout(() => {
            const disabledDay = element.getElementsByClassName("dayId8")[0];
            expect(disabledDay.getAttribute("aria-disabled")).toBe("true");
            const enabledDay = element.getElementsByClassName("dayId15")[0];
            expect(enabledDay.getAttribute("aria-disabled")).toBe("false");
            resolve();
          }, 100);
        });
      });
    });
  });
});
